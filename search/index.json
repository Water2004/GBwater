[{"content":"圆锥曲线垂直弦交点连线过定点 椭圆 命题描述 若直线$l$与椭圆$ C:\\frac{x^2}{a^2}+\\frac{y^2}{b^2}=1$交于A,B,两点,P$(x_0,y_0)\\in C$,且$PA\\perp PB$,则$l$过定点$\\Big (\\frac{a^2-b^2}{a^2+b^2}x_0,-\\frac{a^2-b^2}{a^2+b^2}y_0\\Big )$\n证明 设$A(x_1,y_1)$ , $B(x_2,y_2)$ , $l:y=kx+m$\n先看条件,有一个垂直,用上再说 $$ \\because PA \\perp PB $$ $$ \\therefore k_{PA}\\cdot k_{PB}=-1 \\Rightarrow \\frac{y_0-y_1}{x_0-x_1}\\cdot \\frac{y_0-y_2}{x_0-x_2}=-1 $$\n整理,得: $$ x_0^2-(x_1+x_2)x_0+x_1x_2+y_0^2-(y_1+y_2)y_0+y_1y_2=0 \\tag{1} $$ 按照惯例,联立$C,l$ $$ \\begin{cases} \\frac{x^2}{a^2}+\\frac{y^2}{b^2}=1\\\\\ny=kx+b \\end{cases} \\Rightarrow (b^2+a^2k^2)x^2+2kma^2x+a^2(m^2-b^2)=0 $$ $$ \\therefore x_1+x_2=-\\frac{2kma^2}{b^2+a^2k^2},x_1x_2=\\frac{a^2(m^2-b^2)}{b^2+a^2k^2} $$ 看看还漏了什么\u0026hellip;还有一个$A,B$在$l$上没用\n由$A,B\\in l$ $$ \\begin{cases} y_1=kx_1+m\\\\\ny_2=kx_2+m\\\n\\end{cases} \\therefore \\begin{cases} \u0026amp;y_1+y_2=k(x_1+x_2)+2m=\\frac{2mb^2}{b^2+a^2k^2}\\\\\n\u0026amp;y_1y_2=k^2x_1x_2+km(x_1+x_2)+m^2=\\frac{b^2(m^2-a^2k^2)}{b^2+a^2k^2} \\end{cases} $$ 代入$(1)$得 $$ x_0^2+\\frac{2kma^2}{b^2+a^2k^2}\\cdot x_0+\\frac{a^2(m^2-b^2)}{b^2+a^2k^2}+y_0^2-\\frac{2mb^2}{b^2+a^2k^2}\\cdot y_0+\\frac{b^2(m^2-a^2k^2)}{b^2+a^2k^2}=0 $$ 去分母,得 $$ (b^2+a^2k^2)(x_0^2+y_0^2)+(2kma^2)x_0+a^2(m^2-b^2)+b^2(m^2-a^2k^2)-2mb^2y_0=0 $$ 展开之后有些项长的很像完全平方 按完全平方整理,得 $$ a^2(k^2x_0^2+2kmx_0+m^2)+b^2(m^2-2my_0+y_0^2)+b^2x_0^2-a^2b^2+a^2k^2y_0^2-a^2b^2k^2=0 $$ 即 $$ a^2(kx_0+m)^2+b^2(y_0-m)^2+b^2x_0^2-a^2b^2+a^2k^2y_0^2-a^2b^2k^2=0 \\tag{2} $$ 后面那一坨东西看着就恶心,能不能干掉呢?\n这不还有一个$P$在$C$上没用嘛~\n由$P \\in C$ $$ b^2x_0^2+a^2y_0^2=a^2b^2 $$ 故 $$ b^2x_0^2-a^2b^2+a^2k^2y_0^2-a^2b^2k^2=-a^2y_0^2+k^2(a^2y_0^2-a^2b^2)=-a^2y_0^2-b^2k^2x_0^2 $$ 代入$(2)$,整理,得 $$ a^2[(kx_0+m)^2-y_0^2]=b^2[k^2x_0^2-(y_0-m)^2] $$ 这东西竟然是一个平方差!别急着约分,看看等不等于0先\n$$\\because P \\notin l$$\n$$\\therefore kx_0+m-y_0 \\neq 0$$\n然后就可以开心地约分了! $$ a^2(kx_0+m+y_0)=b^2(kx_0+y_0-m) $$ 故 $$ m=\\frac{(b^2-a^2)(y_0+kx_0)}{a^2+b^2} $$ 故 $$ l: y=kx+\\frac{(b^2-a^2)(y_0+kx_0)}{a^2+b^2} $$ 整理,得 $$ k\\bigg [ x+\\frac{(b^2-a^2)x_0}{a^2+b^2} \\bigg ]=y-\\frac{(b^2-a^2)y_0}{a^2-b^2} $$ 故$l$过定点: $$ \\bigg (\\frac{a^2-b^2}{a^2+b^2}x_0,\\frac{b^2-a^2}{a^2+b^2}y_0 \\bigg ) $$ 单独验证横线和竖线,符合上式 其实是我懒得写\n$$Q.E.D.$$\n双曲线 命题描述 若直线$l$与双曲线$C: \\frac{x^2}{a^2}-\\frac{y^2}{b^2}=1$交于$A,B$两点,$P(x_0,y_0) \\in C$且 $PB \\perp PB$,则$l$过定点$\\Big ( \\frac{a^2+b^2}{a^2-b^2}x_0,-\\frac{a^2+b^2}{a^2-b^2}y_0 \\Big)$\n证明 设$A(x_1,y_1),B(x_2,y_2),l:y=kx+m$\n照例联立$C,l$ $$ \\begin{cases} b^2x^2-a^2y^2-a^2b^2=0\\\\\ny=kx+m \\end{cases} \\Rightarrow (b^2-a^2k^2)x^2-2a^kmx-a^2b^2-a^2m^2=0 $$ $$ \\therefore x_1+x_2=\\frac{2a^2km}{b^2-a^2k^2},x_1x_2=\\frac{-a^2b^2-a^2m^2}{b^2-a^2k^2} $$\n接下来就是垂直了,老是用斜率没意思,用一手向量点乘等于0\n由$PA \\perp PB$ $$ (x_0-x_1)(x_0-x_2)+(y_0-y_1)(y_0-y_2)=0 $$ 由于$A,B$在$l$上,故 $$ \\begin{aligned} y_1=kx_1+m\\\\\ny_2=kx_2+m \\end{aligned} $$ 故上式可化为 $$ (x_0-x_1)(x_0-x_2)+[(y_0-m)-kx_1][(y_0-m)-kx_2]=0 $$ 即\n$$ x_0^2+(y_0-m)^2-[x_0+k(y_0-m)](x_1+x_2)+(k^2+1)x_1x_2=0 $$ 代入韦达定理,得 $$ x_0^2+(y_0-m)^2-\\frac{2a^2km[x_0+k(y_0-m)]}{b^2-a^2k^2}-\\frac{(k^2+1)(a^2b^2+a^2m^2)}{b^2-a^2k^2}=0 $$ 去分母,得 $$ (b^2-a^2k^2)x_0^2+(b^2-a^2k^2)(y_0-m)^2-2a^2km[x_0+k(y_0-m)]-(k^2+1)(a^2b^2+a^2m^2)=0 $$ 隐隐约约看到写完全平方的影子,找出来写在一起: $$ -a^2(k^2x_0^2+2kmx_0+m^2)+b^2x_0^2-a^2k^2[(y_0-m)^2+2m(y_0-m)+m^2]+b^2(y_0-m)^2-k^2a^2b^2-a^2b^2=0 $$ 然后就可以化成平方啦,整体代入不展开真是个好习惯~ $$ -a^2(kx_0+m)^2+b^2x^2-a^2k^2y_0^2+b^2(y_0-m)^2-k^2a^2b^2-a^2b^2=0 \\tag{1} $$ 由$P \\in C$得:$b^2x_0^2-a^2y_0^2-a^2b^2=0$ 故 $$ \\begin{aligned} -a^2y_0^2=a^2b^2-b^2x_0^2\\\\\n-a^2b^2=a^2y_0^2-b^2x_0^2 \\end{aligned} $$ 代入$(1)$,得 $$ \\begin{aligned} \u0026amp;-a^2(kx_0+m)^2+b^2x_0^2+k^2a^2b^2-k^2b^2x_0^2+b^2(y_0-m)^2-k^2a^2b^2+a^2y_0^2-b^2x_0^2=0\\\\\n\u0026amp;\\Leftrightarrow -a^2(kx_0+m)^2+b^2(y_0-m)^2-k^2b^2x_0^2+a^2y_0^2=0\\\\\n\u0026amp;\\Leftrightarrow a^2[y_0-(kx_0+m)^2]+b^2[(y_0-m)^2-k^2x_0^2]=0 \\end{aligned} $$ 然后就来到了喜闻乐见的平方差环节 $$ a^2(y_0+kx_0+m)(y_0-kx_0-m)+b^2(y_0-m+kx_0)(y_0-m-kx_0)=0 $$ 还是要按照惯例判断是否为零\n$$\\because P \\notin C$$\n$$\\therefore y_0-kx_0-m \\neq 0$$\n然后就可以约分啦~ $$ a^2(y_0+kx_0+m)+b^2(y_0+kx_0-m)=0 $$\n$$ \\Rightarrow m=\\frac{(a^2+b^2)y_0+(a^2+b^2)kx_0}{b^2-a^2}=-\\frac{(a^2+b^2)(kx_0+y_0)}{a^2-b^2} $$\n故 $$ l: y=kx-\\frac{(a^2+b^2)(kx_0+y_0)}{a^2-b^2} $$ 单独把$k$拎出来 $$ y+\\frac{y_0(a^2+b^2)}{a^2-b^2}=k\\bigg (x-\\frac{x_0(a^2+b^2)}{a^2-b^2}\\bigg ) $$ 故$l$过定点: $$ \\bigg ( \\frac{a^2+b^2}{a^2-b^2}x_0,-\\frac{a^2+b^2}{a^2-b^2}y_0\\bigg ) $$ 单独验证横线和竖线,符合上式\n$$Q.E.D.$$\n抛物线 命题描述 若直线$l$与抛物线$C: y^2=2px$交于$A,B$两点,$P(x_0,y_0)\\in C$,且$PA \\perp PB$,则$l$过定点$(2p+x_0,-y_0)$\n证明 整完双曲线以为抛物线有手就行,然鹅\u0026hellip;这真是一个悲伤的故事\u0026hellip;\n设$A(x_1,y_1),B(x_2,y_2),l:x=my+n$\n横抛物线肯定是这样设直线简单啦~\n照例联立$C,l$ $$ \\begin{cases} y^2=2px\\\\\nx=my+n \\end{cases} \\Rightarrow y^2=2pmy-2pn=0 $$ $$ \\therefore y_1+y_2=2pm,y_1y_2=-2pn $$ 照例向量点乘等于0\n$$\\because PA \\perp PB$$\n$$\\therefore (y_0-y_1)(y_0-y_2)+(x_0-x_1)(x_0-x_2)=0$$\n由于$A,B$在$l$上 $$ \\begin{aligned} x_1=my_1+n\\\\\nx_2=my_2+n \\end{aligned} $$ 代入上式,得\n$$ y_0^2+(x_0-n)^2-[y_0+m(x_0-n)](y_1+y_2)+(m^2+1)y_1y_2=0 $$ 代入韦达定理,得 $$ \\begin{aligned} \u0026amp;y_0^2+(x_0-n)^2-2pm[y_0+m(x_0-n)]-2pm^2n-2pn=0\\\\\n\u0026amp;\\Leftrightarrow y_0^2-2pmy_0+(x_0-n)^2-2pm^2x_0-2pn=0 \\end{aligned} $$ $$\\because P \\in C$$\n$$\\therefore y_0^2=2px_0$$\n代入上式,然后是一通十分Genius的操作,注意,核心所在! 我是怎么想出来的?\n$$ \\begin{aligned} \u0026amp;y_0^2-2pmy_0+(x_0-n)^2-m^2y_0-2pn=0\\\\\n\u0026amp;\\Leftrightarrow (1-m^2)y_0^2-2pmy_0+(x_0-n)^2-2pn=0\\\\\n\u0026amp;\\Leftrightarrow (1-m^2)y_0^2-2pmy_0-p^2+(x_0-n)^2-2pn+p^2 \\leftarrow 妙不可言!\\\\\n\u0026amp;\\Leftrightarrow [(1+m)y_0+p][(1-m)y_0-p]+(x-n+p)^2-2px_0=0\\\\\n\u0026amp;\\Leftrightarrow (y_0+my_0+p)(y_0-my_0-p)+(x_0-n+p)^2-y_0^2=0\\\\\n\u0026amp;\\Leftrightarrow y_0^2-(my_0+p)^2+(x_0-n+p)^2-y_0^2=0\\\\\n\u0026amp;\\Leftrightarrow (x_0-m+p)^2-(my_0+p)^2=0 \\end{aligned} $$ 然后就又到了喜闻乐见的平方差环节 $$ (x_0-n+p+my_0+p)(x_0-n+p-my_0-p)=0 $$ 即 $$ (x_0-n+my_0+2p)(x_0-n-my_0)=0 $$ 剩下的就是常规操作啦\n$$\\because P \\notin C$$\n$$\\therefore x_0-n-my_0 \\neq 0$$\n故 $$ \\begin{aligned} x_0-n+my_0+2p=0\\\\\n\\Rightarrow n=my_0+x_0+2p \\end{aligned} $$ 然后就可以愉快地写出直线的方程 $$ l: x=my+my_0+x_0+2p $$ 还是把$m$单独拿出来 $$ x-(x_0+2p)=m(y+y_0) $$ 故$l$过定点: $$ (x_0+2p,-y_0) $$ 单独验证横线和竖线,符合上式\n$$Q.E.D.$$\n花絮 看到这里,你一定很好奇我到底算了多久吧?你一定很好奇我是怎么想到做法的吧?不如来看看这4大张草稿纸吧(笑~)\n参考资料 椭圆证明来自:爱数学的筑梦人:曲线上定点引垂直弦，交点连线过定点\n封面图:知乎:【解析几何】什么是极线，好吃吗?\n","date":"2021-02-27T00:00:00Z","image":"https://s3.ax1x.com/2021/02/28/69Z2AP.jpg","permalink":"https://gbwater.ga/p/%E5%9C%86%E9%94%A5%E6%9B%B2%E7%BA%BF%E5%9E%82%E7%9B%B4%E5%BC%A6%E4%BA%A4%E7%82%B9%E8%BF%9E%E7%BA%BF%E8%BF%87%E5%AE%9A%E7%82%B9/","title":"圆锥曲线垂直弦交点连线过定点"},{"content":"deepin入坑指南——使用you-get下载主流视频网站的视频 安装和配置pip3 安装pip3 首先安装pip3,终端输入命令:\n1  sudo apt install python3-pip   更换国内源 临时使用可以加上-i参数,指定pip源,例如\n1  pip install you-get -i https://pypi.tuna.tsinghua.edu.cn/simple   永久修改则修改~/.pip/pip.conf(没有就创建一个)， 内容如下\n[global] index-url = https://pypi.tuna.tsinghua.edu.cn/simple 一些国内的镜像源:\n 阿里云 http://mirrors.aliyun.com/pypi/simple/ 中国科技大学 https://pypi.mirrors.ustc.edu.cn/simple/ 豆瓣 http://pypi.douban.com/simple/ 清华大学 https://pypi.tuna.tsinghua.edu.cn/simple/ 中国科学技术大学 http://pypi.mirrors.ustc.edu.cn/simple/  安装you-get 终端输入命令\n1  sudo pip3 install you-get   若要更新,使用命令\n1  pip3 install --upgrade you-get   使用you-get 下载指定格式的视频 首先使用\u0026ndash;info或者-i参数获取视频信息\n1  you-get -i \u0026lt;url\u0026gt;   这里的url就是浏览器访问视频时地址框里的那个\n例如,如果我要下载爱奇艺上的德云社春晚相声,就在终端输入\n1  you-get -i https://www.iqiyi.com/v_19rx2ez0w4.html   这时you-get的输出如下\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42  you-get: vd: 75 is not handled you-get: info is {\u0026#39;m3utx\u0026#39;: \u0026#39;http://cache.m.iqiyi.com/mus/text/250351801/b5d8357ec33641c316bf0a0dc7adb8bb/afbe8fd3d73448c9/0/20200329/c8/99/ccd2f230c814c2aab54a6994e7433afb.m3u8?qd_originate=tmts_py\u0026amp;tvid=14281781800\u0026amp;bossStatus=0\u0026amp;qd_vip=0\u0026amp;px=\u0026amp;src=3_31_312\u0026amp;prv=\u0026amp;previewType=\u0026amp;previewTime=\u0026amp;from=\u0026amp;qd_time=1613129716572\u0026amp;qd_p=0e9d4591\u0026amp;qd_asc=4af38ab6f480b859f7b88d496c8c019e\u0026amp;qypid=14281781800_04022000001000000000_75\u0026amp;qd_k=2004ae445e0a1b1825cfd616d87f3c93\u0026amp;isdol=0\u0026amp;code=2\u0026amp;ff=f4v\u0026amp;iswb=0\u0026amp;qd_s=otv\u0026amp;vf=4b7c73268eb847d33a7cfeaba213652d\u0026amp;np_tag=nginx_part_tag\u0026#39;, \u0026#39;lgt\u0026#39;: 13, \u0026#39;mver\u0026#39;: 100, \u0026#39;screenSize\u0026#39;: \u0026#39;896x504\u0026#39;, \u0026#39;ists\u0026#39;: 1, \u0026#39;unencryptedDuration\u0026#39;: 0, \u0026#39;vd\u0026#39;: 75, \u0026#39;m3u\u0026#39;: \u0026#39;http://cache.m.iqiyi.com/mus/250351801/b5d8357ec33641c316bf0a0dc7adb8bb/afbe8fd3d73448c9/0/20200329/c8/99/ccd2f230c814c2aab54a6994e7433afb.m3u8?qd_originate=tmts_py\u0026amp;tvid=14281781800\u0026amp;bossStatus=0\u0026amp;qd_vip=0\u0026amp;px=\u0026amp;src=3_31_312\u0026amp;prv=\u0026amp;previewType=\u0026amp;previewTime=\u0026amp;from=\u0026amp;qd_time=1613129716572\u0026amp;qd_p=0e9d4591\u0026amp;qd_asc=4af38ab6f480b859f7b88d496c8c019e\u0026amp;qypid=14281781800_04022000001000000000_75\u0026amp;qd_k=2004ae445e0a1b1825cfd616d87f3c93\u0026amp;isdol=0\u0026amp;code=2\u0026amp;ff=f4v\u0026amp;iswb=0\u0026amp;qd_s=otv\u0026amp;vf=4b7c73268eb847d33a7cfeaba213652d\u0026amp;np_tag=nginx_part_tag\u0026#39;, \u0026#39;code\u0026#39;: 2, \u0026#39;dr\u0026#39;: -1, \u0026#39;drmType\u0026#39;: 1, \u0026#39;vid\u0026#39;: \u0026#39;b5d8357ec33641c316bf0a0dc7adb8bb\u0026#39;} site: 爱奇艺 (Iqiyi) title: 2020天津卫视德云社相声春晚之精编版（下） streams: # Available quality and codecs [ DEFAULT ] _________________________________ - format: TD container: m3u8 video-profile: 720p m3u8_url: http://cache.m.iqiyi.com/mus/250351801/4fc7566f752ca2c20ee1894df99f3453/afbe8fd3d73448c9/0/20201029/55/b3/e55e81f305266eedc05bc074d249a6ef.m3u8?qd_originate=tmts_py\u0026amp;tvid=14281781800\u0026amp;bossStatus=0\u0026amp;qd_vip=0\u0026amp;px=\u0026amp;src=3_31_312\u0026amp;prv=\u0026amp;previewType=\u0026amp;previewTime=\u0026amp;from=\u0026amp;qd_time=1613129716572\u0026amp;qd_p=0e9d4591\u0026amp;qd_asc=5d4075f202f2fb30c7fdce7f8c417e54\u0026amp;qypid=14281781800_04022000001000000000_4\u0026amp;qd_k=2004ae445e0a1b1825cfd616d87f3c93\u0026amp;isdol=0\u0026amp;code=2\u0026amp;ff=f4v\u0026amp;iswb=0\u0026amp;qd_s=otv\u0026amp;vf=fd25d9f6bc8aa66ca5e06de000b36658\u0026amp;np_tag=nginx_part_tag # download-with: you-get --format=TD [URL] - format: TD_H265 container: m3u8 video-profile: 720p H265 m3u8_url: http://cache.m.iqiyi.com/mus/250351801/2b2b080be951084fab021dc1249384ef/afbe8fd3d73448c9/0/20201029/55/b3/0d6fcc58ff080f575ed5a4386cda8356.m3u8?qd_originate=tmts_py\u0026amp;tvid=14281781800\u0026amp;bossStatus=0\u0026amp;qd_vip=0\u0026amp;px=\u0026amp;src=3_31_312\u0026amp;prv=\u0026amp;previewType=\u0026amp;previewTime=\u0026amp;from=\u0026amp;qd_time=1613129716572\u0026amp;qd_p=0e9d4591\u0026amp;qd_asc=26fa4e7c5403eee1942e73344f47c57c\u0026amp;qypid=14281781800_04022000001000000000_17\u0026amp;qd_k=2004ae445e0a1b1825cfd616d87f3c93\u0026amp;isdol=0\u0026amp;code=1\u0026amp;ff=265ts\u0026amp;iswb=0\u0026amp;qd_s=otv\u0026amp;vf=e10bf652e02b1611a2de6a7c498c3329\u0026amp;np_tag=nginx_part_tag # download-with: you-get --format=TD_H265 [URL] - format: HD container: m3u8 video-profile: 540p m3u8_url: http://cache.m.iqiyi.com/mus/250351801/3297bf14ce29680457e74bd3b29655fc/afbe8fd3d73448c9/0/20201029/55/b3/6111cf77ca9d50b5c836493d3e274487.m3u8?qd_originate=tmts_py\u0026amp;tvid=14281781800\u0026amp;bossStatus=0\u0026amp;qd_vip=0\u0026amp;px=\u0026amp;src=3_31_312\u0026amp;prv=\u0026amp;previewType=\u0026amp;previewTime=\u0026amp;from=\u0026amp;qd_time=1613129716572\u0026amp;qd_p=0e9d4591\u0026amp;qd_asc=02e9664c7cff7ff4c5602f30c9dcea89\u0026amp;qypid=14281781800_04022000001000000000_2\u0026amp;qd_k=2004ae445e0a1b1825cfd616d87f3c93\u0026amp;isdol=0\u0026amp;code=2\u0026amp;ff=f4v\u0026amp;iswb=0\u0026amp;qd_s=otv\u0026amp;vf=796575d2118904ecdab75e98af416dce\u0026amp;np_tag=nginx_part_tag # download-with: you-get --format=HD [URL] - format: HD_H265 container: m3u8 video-profile: 540p H265 m3u8_url: http://cache.m.iqiyi.com/mus/250351801/31bc12eef9157c0fa186664858bfe712/afbe8fd3d73448c9/0/20201029/55/b3/58650d10ae97ea73506f1041d72e4dac.m3u8?qd_originate=tmts_py\u0026amp;tvid=14281781800\u0026amp;bossStatus=0\u0026amp;qd_vip=0\u0026amp;px=\u0026amp;src=3_31_312\u0026amp;prv=\u0026amp;previewType=\u0026amp;previewTime=\u0026amp;from=\u0026amp;qd_time=1613129716572\u0026amp;qd_p=0e9d4591\u0026amp;qd_asc=cfbf044d5dfa5b87d7d0d1d090e4886b\u0026amp;qypid=14281781800_04022000001000000000_21\u0026amp;qd_k=2004ae445e0a1b1825cfd616d87f3c93\u0026amp;isdol=0\u0026amp;code=1\u0026amp;ff=265ts\u0026amp;iswb=0\u0026amp;qd_s=otv\u0026amp;vf=e1b20f06c858cdf7d55590f459f480bc\u0026amp;np_tag=nginx_part_tag # download-with: you-get --format=HD_H265 [URL] - format: SD container: m3u8 video-profile: 360p m3u8_url: http://cache.m.iqiyi.com/mus/250351801/5d7a91960ce5b8c049136e4be8d0c4ac/afbe8fd3d73448c9/0/20200329/c8/99/946add8a95cc05f129fc1d5d0ac9da14.m3u8?qd_originate=tmts_py\u0026amp;tvid=14281781800\u0026amp;bossStatus=0\u0026amp;qd_vip=0\u0026amp;px=\u0026amp;src=3_31_312\u0026amp;prv=\u0026amp;previewType=\u0026amp;previewTime=\u0026amp;from=\u0026amp;qd_time=1613129716572\u0026amp;qd_p=0e9d4591\u0026amp;qd_asc=5f34d251fe608a49cfdd0c584ec27667\u0026amp;qypid=14281781800_04022000001000000000_1\u0026amp;qd_k=2004ae445e0a1b1825cfd616d87f3c93\u0026amp;isdol=0\u0026amp;code=2\u0026amp;ff=f4v\u0026amp;iswb=0\u0026amp;qd_s=otv\u0026amp;vf=f172ed9a453a415f9b7425254fb93444\u0026amp;np_tag=nginx_part_tag # download-with: you-get --format=SD [URL] - format: LD container: m3u8 video-profile: 210p m3u8_url: http://cache.m.iqiyi.com/mus/250351801/0b184d7790ebe24ce40d6a42d4a87927/afbe8fd3d73448c9/0/20200329/c8/99/5f0701913828afadb29cd633c1c0744b.m3u8?qd_originate=tmts_py\u0026amp;tvid=14281781800\u0026amp;bossStatus=0\u0026amp;qd_vip=0\u0026amp;px=\u0026amp;src=3_31_312\u0026amp;prv=\u0026amp;previewType=\u0026amp;previewTime=\u0026amp;from=\u0026amp;qd_time=1613129716572\u0026amp;qd_p=0e9d4591\u0026amp;qd_asc=7bccc88a2ca1cd6e26843180eb3b20f6\u0026amp;qypid=14281781800_04022000001000000000_96\u0026amp;qd_k=2004ae445e0a1b1825cfd616d87f3c93\u0026amp;isdol=0\u0026amp;code=2\u0026amp;ff=f4v\u0026amp;iswb=0\u0026amp;qd_s=otv\u0026amp;vf=251ad0fd24c007bc80630a1647da6ff9\u0026amp;np_tag=nginx_part_tag # download-with: you-get --format=LD [URL]   这里的第六行往下就是可选下载的视频了\n注意前面有一个\u0026quot;-\u0026ldquo;号的条目,这里是format.所以在下载的时候应该输入\n1  you-get --format=\u0026lt;-format后面的那个\u0026gt; https://www.iqiyi.com/v_19rx2ez0w4.html   在每一个可选视频的最下面,you-get也给出了提示:download-with XXX,只需要把[URL]替换成要下载的视频的链接即可,例如\n1  you-get --format=TD https://www.iqiyi.com/v_19rx2ez0w4.html   如果不使用-i参数,那么会默认直接下载第一个视频\n然后,你就可以在当前终端的目录找到这个视频了\n设置输出路径 如果要指定下载到的目录,则可以使用-o选项后面加上输出文件夹的路径,例如我要把春晚德云社的相声存到桌面上,就可以输入\n1  you-get -o ~/Desktop --format=TD https://www.iqiyi.com/v_19rx2ez0w4.html   加载cookies以下载vip视频 有一些视频是要vip才能下载的,这时就可以加载cookies(保存登录信息,这要求先登录vip账号),这时就可以使用其加载cookies的功能\n在linux下,you-get目前仅支持firefox的cookies,文件名是cookies.sqlite,路径是~/.mozilla/firefox/XXX.default-release/cookies.sqlite\n要加载cookie,使用-c选项加上cookies.sqlite的路径,例如\n1  you-get --format=TD https://www.iqiyi.com/v_19rx2ez0w4.html -c=~/Desktop/cookies.sqlite   参考资料 PIP 更换国内安装源\ngithub:you-get\ncookie 存放地点\nyou-get下载会员视频使用-c参数导入cookies.sqlite文件\n","date":"2021-02-12T00:00:00Z","image":"https://s3.ax1x.com/2021/01/31/yA4cJs.jpg","permalink":"https://gbwater.ga/p/deepin%E5%85%A5%E5%9D%91%E6%8C%87%E5%8D%97%E4%BD%BF%E7%94%A8you-get%E4%B8%8B%E8%BD%BD%E4%B8%BB%E6%B5%81%E8%A7%86%E9%A2%91%E7%BD%91%E7%AB%99%E7%9A%84%E8%A7%86%E9%A2%91/","title":"deepin入坑指南——使用you-get下载主流视频网站的视频"},{"content":"前言 没想到我竟然能有幸成为参加noip2020中7k+人的一员话说不是有分就能去的吗今天考完了，特地来写个小结\n赛前准备 虽然在考完csp后并不认为我能参加noip，但我还是去机房参加训练（毕竟万一进了不是很亏？）在得知noip有分就行的消息后，我更加努力地准备腐\n于是在洛谷上做了一些题。为什么是做了一些题呢？因为我太菜了，做一道题都要很久QAQ。到了比赛前没有奥赛课的时候，我看那些高三大佬都翘课来准备，于是我周三周四的晚修请假来机房训练（还不敢翘课）。在这两个晚上，我着重搞了搞之前鸽了很久都快忘了的算法，包括但不限于线段树，树链剖分，并查集，最小生成树，最短路，倍增LCA（主要是我也忘了我搞了啥）\n这里有一点经验，就是在学算法的时候不要看别人的代码，自己按照思路写印象会更深刻，捡起来也会更快。还有，写板子但时候一定要打上完备的注释（我基本一行一个），这样每次只要看看注释就知道自己当时在想什么了。最好还能有自己的blog，当然用markdown渲染也行。\n最令人惊讶的是有一位大佬竟然在进场的时候前提到了gcd！然后我才发现我在准备的时候忘记搞gcd了！这波要是他不提一下我t1就凉了，妙啊！说的好像t1没凉一样\n来自大佬的gcd超短模板\n1 2 3 4  ll gcd(ll a,ll b) { return b? gcd(b,a%b):a; }   一些坑点  判断换行符的时候要判三个：‘\\n’‘\\r’‘\\n\\r’ (我就是因为这个洛谷上一题爆零了) printf(\u0026quot;%s\u0026quot;,\u0026ldquo;str\u0026rdquo;)会re(上面那位大佬就是因为这个noip一题爆零了,申诉还不让过,说是编译器bug人人平等???)  t1 water 题目传送门\n上来一眼看到还以为是网络流！真是骇死我了。。。。。。\n然后瞎写了一阵，把样例打进去，咦？怎么输入还没完就输出答案了？才发现还有中间节点QAQ\n于是删掉重来，一开始就想到了bfs，但是STL的queue不会用，主要是不知道怎么取出队头。。。。。。那就手写吧！于是手写了top，empty，push和pop。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  int que[1000010]; int front=0;int tail=0; int top() { return que[front]; } void pop() { if(front\u0026lt;tail) front++; } void push(int a) { que[tail++]=a; } bool empty() { return front==tail; }   然后又写了个分数的结构体，用构造函数初始化分母为1。由于之前重载运算符写吐了，这次直接就写了两个函数，一个搞加法，一个搞除法。\n然而一输样例，发现竟然输出了负数！于是把int 改了ll，问题依旧。后来把通分时算lcm先乘后除就好了。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29  struct fen { ll up; ll down; fen() { down=1; } }; fen add(fen \u0026amp;a,fen b) { ll g=gcd(a.down,b.down); ll lcm=a.down/g*b.down; a.up*=lcm/a.down; b.up*=lcm/b.down; a.up+=b.up; a.down=lcm; g=gcd(a.up,a.down); a.up/=g; a.down/=g; return a; } void chu(fen \u0026amp;a,int b) { a.down*=b; ll g =gcd(a.up,a.down); a.up/=g; a.down/=g; }   这里要注意一点，这里不只是bfs就行了的，节点要先把水都排进来最后才能排出去，也就是说当一个节点的流入全部算完后才能入队去算流出。这不就是拓扑序嘛。。。。。。emmmm，调的我有亿点久QAQ\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20  void bfs() { while(!empty()) { int now=top(); pop(); int h=head[now]; fen water; water.up=out[now].up; water.down=out[now].down; chu(water,tot[now]); while(h) { --intot[E[h].to]; add(out[E[h].to],water); if(!intot[E[h].to]) push(E[h].to); h=E[h].next; } } }   然而！数据范围是100000而我看成了1000。。。。。。又是一个100变60的伤心故事。。。。。。\nps:猥琐的ccf的猥琐数据的最后一个点爆了unsigned long long!我不觉得有哪个人会在考场上写高精度QAQ\n完整代码:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142  #include\u0026lt;cstdio\u0026gt;#define ll long long using namespace std; ll gcd(ll a,ll b) { return b? gcd(b,a%b):a; } struct fen { ll up; ll down; fen() { down=1; } }; fen add(fen \u0026amp;a,fen b) { ll g=gcd(a.down,b.down); ll lcm=a.down/g*b.down; a.up*=lcm/a.down; b.up*=lcm/b.down; a.up+=b.up; a.down=lcm; g=gcd(a.up,a.down); a.up/=g; a.down/=g; return a; } ll rd() { ll num=0;bool f=false;char c=getchar(); while(c\u0026lt;\u0026#39;0\u0026#39;||c\u0026gt;\u0026#39;9\u0026#39;) { if(c==\u0026#39;-\u0026#39;) f=true; c=getchar(); } while(c\u0026gt;=\u0026#39;0\u0026#39;\u0026amp;\u0026amp;c\u0026lt;=\u0026#39;9\u0026#39;) { num=(num\u0026lt;\u0026lt;1)+(num\u0026lt;\u0026lt;3)+(c^\u0026#39;0\u0026#39;); c=getchar(); } if(f) return -num; else return num; } fen out[100010]; ll tot[100010]; struct edge { int to; int next; }E[101000]; int head[101000];int cnt=0; void add_edge(int a,int b) { E[++cnt].to=b; E[cnt].next=head[a]; head[a]=cnt; } void chu(fen \u0026amp;a,int b) { a.down*=b; ll g =gcd(a.up,a.down); a.up/=g; a.down/=g; } int que[1000010]; int front=0;int tail=0; int top() { return que[front]; } void pop() { if(front\u0026lt;tail) front++; } void push(int a) { que[tail++]=a; } bool empty() { return front==tail; } int intot[100010]; void bfs() { while(!empty()) { int now=top(); pop(); int h=head[now]; fen water; water.up=out[now].up; water.down=out[now].down; chu(water,tot[now]); while(h) { --intot[E[h].to]; add(out[E[h].to],water); if(!intot[E[h].to]) push(E[h].to); h=E[h].next; } } } int final[100010]; int Ftot=0; signed main() { freopen(\u0026#34;water.in\u0026#34;,\u0026#34;r\u0026#34;,stdin); freopen(\u0026#34;water.out\u0026#34;,\u0026#34;w\u0026#34;,stdout); //int n=rd(),m=rd(); \tint n,m; scanf(\u0026#34;%d\u0026#34;,\u0026amp;n); scanf(\u0026#34;%d\u0026#34;,\u0026amp;m); for(int i=1;i\u0026lt;=n;i++) { //tot[i]=rd(); \tscanf(\u0026#34;%lld\u0026#34;,\u0026amp;tot[i]); if(!tot[i]) final[++Ftot]=i; for(int j=0;j\u0026lt;tot[i];j++) { int to; scanf(\u0026#34;%d\u0026#34;,\u0026amp;to); add_edge(i,to); ++intot[to]; } } for(int i=1;i\u0026lt;=m;i++) { out[i].up=1; push(i); } bfs(); for(int i=1;i\u0026lt;=Ftot;i++) { printf(\u0026#34;%lld %lld\\n\u0026#34;,out[final[i]].up,out[final[i]].down); } fclose(stdin); fclose(stdout); return 0; }   t2 string 题目传送门\n这种题一看就不会。我估摸着应该是dp，但是这和我不会有什么关系呢？\n于是随便写了点东西没思路就走了，最后用半个小时写了只有1个字母的情况。但是复杂度有亿点大。嗯，好问题。。。。。。 关键是这种情况都没写对QAQ\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46  #include\u0026lt;cstdio\u0026gt;using namespace std; char s[100010000]; int rdstr() { char c=getchar(); while(c\u0026lt;\u0026#39;a\u0026#39;||c\u0026gt;\u0026#39;z\u0026#39;) c=getchar(); int len=0; while(c\u0026lt;=\u0026#39;z\u0026#39;\u0026amp;\u0026amp;c\u0026gt;=\u0026#39;a\u0026#39;) { s[len++]=c; c=getchar(); } return len; } int main() { freopen(\u0026#34;string.in\u0026#34;,\u0026#34;r\u0026#34;,stdin); freopen(\u0026#34;string.out\u0026#34;,\u0026#34;w\u0026#34;,stdout); int T; scanf(\u0026#34;%d\u0026#34;,\u0026amp;T); while(T--) { int ans=0; int len=rdstr(); for(int i=1;i\u0026lt;len-1;i++) { int left=len-i; for(int j=1;j\u0026lt;=(left\u0026gt;\u0026gt;1);j++) { if(left%j) continue; int tot=left/j; for(int k=1;k\u0026lt;tot;k++) { if(k%2\u0026gt;i%2) continue; ans++; } } } printf(\u0026#34;%d\\n\u0026#34;,ans); } fclose(stdin); fclose(stdout); return 0; }   t3 ball 难得noip竟然考spj！spj都来了，交互题还会远吗？\n看到这玩意，第一反应就是不会做。不会做咋办，那就来打个暴力吧。一开始想了一大堆方案，比如从上往下找同色珠子集中到一根柱子上之类的，但都要么不可行，主要是要么不会写。到最后，想到要是能交换两根柱子上的任意两个珠子就好了。我盲猜用一根空的柱子是可以的，于是开始研究，最后还真给研究出来了！\n首先先确定两颗珠子的深度大小关系,防止下面操作的时候爆柱子\n1 2 3 4 5 6 7 8 9  if(i\u0026gt;j) //i\u0026lt;j { int c=b; b=a; a=c; c=j; j=i; i=c; }   然后把深度大的那一串(a)连带着要移动的那一颗移到空柱子上\n1 2 3 4 5 6 7 8  for(int k=tot[a];k\u0026gt;=i;k--)//a:i~top to empty { //printf(\u0026#34;%d %d\\n\u0026#34;,a,empty); \tmem(a,empty); tot[a]--; stick[empty][++tot[empty]]=stick[a][k]; ++atot; }   然后把深度小的那一串(b)连带着要移动的那一颗移到刚刚移走一串的那根柱子(a)上.由于a上移走的那一串要比这一串多,所以不会爆出柱子\n1 2 3 4 5 6 7 8  for(int k=tot[b];k\u0026gt;=j;k--)//b:j~top to a { //printf(\u0026#34;%d %d\\n\u0026#34;,b,a); \tmem(b,a); tot[b]--; stick[a][++tot[a]]=stick[b][k]; ++btot; }   然后我们就可以把原本属于a的那一颗移到b上.柱子类似栈,移动完是倒序的,所以刚刚要交换的两颗珠子现在都到了最上面\n1 2 3 4  //printf(\u0026#34;%d %d\\n\u0026#34;,empty,b);//empty: top to b mem(empty,b); stick[b][++tot[b]]=stick[empty][tot[empty]--]; --btot;   然后就要把刚刚从b上移走的那一串还回来,当然,要移到a上的那一颗先放到empty上.由于empty刚刚移走了一颗,这样做仍然不会爆柱子\n1 2 3 4 5 6 7 8 9  //printf(\u0026#34;%d %d\\n\u0026#34;,a,empty);//a:top to empty mem(a,empty); stick[empty][++tot[empty]]=stick[a][tot[a]--]; for(int k=0;k\u0026lt;btot;k++)//a:j~top to b { //printf(\u0026#34;%d %d\\n\u0026#34;,a,b); \tmem(a,b); stick[b][++tot[b]]=stick[a][tot[a]--]; }   这样做完,a上要移动到的那个位置就暴露出来了,把empty上的东西移动回来就可以了\n1 2 3 4 5 6  for(int k=tot[empty];k\u0026gt;0;k--)//empty to a { //printf(\u0026#34;%d %d\\n\u0026#34;,empty,a); \tmem(empty,a); stick[a][++tot[a]]=stick[empty][tot[empty]--]; }   然后主程序就简单了,不妨认为一根柱子最下面的那一颗是这跟柱子的颜色(反正题目也没规定),前面的柱子都移动好了,从上往下一旦遇到不一样颜色的珠子,就在后面的柱子上找一个颜色一样的交换一下就行了\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24  for(int i=1;i\u0026lt;n;i++) { int k=i+1; int l=m; for(int j=2;j\u0026lt;=m;j++) { if(stick[i][j]==stick[i][1]) continue; for(;k\u0026lt;=n;k++) { bool flag =false; if(!l) l=m; for(;l\u0026gt;0;l--) { if(stick[k][l]==stick[i][1]) { change(i,j,k,l); flag=true; break; } } if(flag) break; } } }   但是由于复杂度太大，经过了不懈随意地卡常，大样例还是跑了1.4s，不过还好答案是对的,最后骗到了40分。\n完整代码:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121  #include\u0026lt;cstdio\u0026gt;using namespace std; int stick[60][410]; int tot[60]; int empty; int ans1[820010],ans2[820010]; int cnt=0; void mem(int a,int b) { ans1[++cnt]=a; ans2[cnt]=b; } int rd() { int num=0;char c=getchar(); while(c\u0026lt;\u0026#39;0\u0026#39;||c\u0026gt;\u0026#39;9\u0026#39;) c=getchar(); while(c\u0026gt;=\u0026#39;0\u0026#39;\u0026amp;\u0026amp;c\u0026lt;=\u0026#39;9\u0026#39;) { num=(num\u0026lt;\u0026lt;1)+(num\u0026lt;\u0026lt;3)+(c^\u0026#39;0\u0026#39;); c=getchar(); } return num; } void change(int a,int i,int b,int j)//change a[i] and b[j] { if(i\u0026gt;j) //i\u0026lt;j \t{ int c=b; b=a; a=c; c=j; j=i; i=c; } int atot=0,btot=0; for(int k=tot[a];k\u0026gt;=i;k--)//a:i~top to empty \t{ //printf(\u0026#34;%d %d\\n\u0026#34;,a,empty); \tmem(a,empty); tot[a]--; stick[empty][++tot[empty]]=stick[a][k]; ++atot; } for(int k=tot[b];k\u0026gt;=j;k--)//b:j~top to a \t{ //printf(\u0026#34;%d %d\\n\u0026#34;,b,a); \tmem(b,a); tot[b]--; stick[a][++tot[a]]=stick[b][k]; ++btot; } //printf(\u0026#34;%d %d\\n\u0026#34;,empty,b);//empty: top to b \tmem(empty,b); stick[b][++tot[b]]=stick[empty][tot[empty]--]; --btot; //printf(\u0026#34;%d %d\\n\u0026#34;,a,empty);//a:top to empty \tmem(a,empty); stick[empty][++tot[empty]]=stick[a][tot[a]--]; for(int k=0;k\u0026lt;btot;k++)//a:j~top to b \t{ //printf(\u0026#34;%d %d\\n\u0026#34;,a,b); \tmem(a,b); stick[b][++tot[b]]=stick[a][tot[a]--]; } for(int k=tot[empty];k\u0026gt;0;k--)//empty to a \t{ //printf(\u0026#34;%d %d\\n\u0026#34;,empty,a); \tmem(empty,a); stick[a][++tot[a]]=stick[empty][tot[empty]--]; } } int main() { freopen(\u0026#34;ball.in\u0026#34;,\u0026#34;r\u0026#34;,stdin); freopen(\u0026#34;ball.out\u0026#34;,\u0026#34;w\u0026#34;,stdout); int n=rd(),m=rd(); //scanf(\u0026#34;%d%d\u0026#34;,\u0026amp;n,\u0026amp;m); \tfor(int i=1;i\u0026lt;=n;i++) { tot[i]=m; for(int j=1;j\u0026lt;=m;j++) { //scanf(\u0026#34;%d\u0026#34;,\u0026amp;stick[i][j]); \tstick[i][j]=rd(); } } empty=n+1; for(int i=1;i\u0026lt;n;i++) { int k=i+1; int l=m; for(int j=2;j\u0026lt;=m;j++) { if(stick[i][j]==stick[i][1]) continue; for(;k\u0026lt;=n;k++) { bool flag =false; if(!l) l=m; for(;l\u0026gt;0;l--) { if(stick[k][l]==stick[i][1]) { change(i,j,k,l); flag=true; break; } } if(flag) break; } } } printf(\u0026#34;%d\\n\u0026#34;,cnt); for(int i=1;i\u0026lt;=cnt;i++) { printf(\u0026#34;%d %d\\n\u0026#34;,ans1[i],ans2[i]); } fclose(stdin); fclose(stdout); return 0; }   t4 walk 题目传送门\n这是人能做的题吗？输-1拿5分就回去调t1去了最后发现骗到了十分\n1 2 3 4 5 6 7 8 9 10  #include\u0026lt;cstdio\u0026gt;using namespace std; int main() { freopen(\u0026#34;walk.out\u0026#34;,\u0026#34;w\u0026#34;,stdout); printf(\u0026#34;-1\u0026#34;); fclose(stdout); return 0; }   小结  带零食没有用处，因为你根本就没有心思吃 比赛前多多交流很重要 大胆尝试，不会就打暴力（当然也有可能连暴力都打不出来） 心态很重要，部分分还是可以拿一下的 眼睛是个好东西QAQ  一些有趣的事情 训练的时候，写完快读突发奇想\n众所周知在main函数外面是不能执行函数的，但是把函数的返回值赋给变量竟然还就可以了！\n至于怎么结束程序不re,不是可以用exit(0)嘛~\n甚至都不需要main函数，有个main数组或是main指针竟然还能顺利通过编译！\n感受一下不用main就能执行的a+b(虽然洛谷上会CE)\n","date":"2021-02-12T00:00:00Z","image":"https://s3.ax1x.com/2020/11/22/D3BGc9.jpg","permalink":"https://gbwater.ga/p/noip2020%E5%B0%8F%E7%BB%93/","title":"NOIP2020小结"},{"content":"deepin20编译安装dde-top-panel 依赖 libqt5widgets5 libqt5concurrent5 libqt5x11extras5-dev libqt5svg5-dev libdtkwidget-dev libkf5windowsystem-dev libdframeworkdbus-dev libdtkgui-dev cmake libdtkcore-bin g++ libxdo-dev libdtkcore5-bin libxcb-ewmh-dev libgsettings-qt-dev qt5-default\n下载文件 下载dde-top-panel的源代码和release\n下载全局菜单的release\n编译 顶栏高度的配置在/dde-top-panel-master/frame/util/CustomSettings.cpp的25行\n进入dde-top-panel目录，执行：\n1 2 3 4  mkdir build cd build cmake .. make   注意，源码的路径里不能有中文！\n编译出的文件会在：build/frame/dde-top-panel\n安装dde-top-panel   将com.deepin.dde.toppanel.gschema.xml 复制到/usr/share/glib-2.0/schemas\n  执行\n1  sudo glib-compile-schemas /usr/share/glib-2.0/schemas     赋予dde-top-panel可执行权限：\n1  chmod +x dde-top-panel     将dde-top-panel复制到你喜欢的目录（比如/opt），记下路径\n  新建一个文本文档，输入以下内容：\n [Desktop Entry] Comment=DDE Top Panel Exec=/opt/dde-top-panel Hidden=false Name=dde-top-panel Type=Application X-Deepin-Vendor=user-custom X-GNOME-Autostart-enabled=true\n 其中的“Exec=”后面的内容替换为dde-top-panel可执行文件的路径，要写完整路径！\n  将这个文件的扩展名由.txt改为.desktop\n  将这个文件复制到~/.config/autostart\n  注销或重启或者直接双击运行\n  启用全局菜单  赋予dde-globalmenu-service可执行权限 复制 dde-globalmenu-service 到 /usr/bin 复制 dde-globalmenu-service.desktop 到 ~/.config/autostart 修改文件 ~/.gtkrc-2.0 ，添加 gtk-modules=appmenu-gtk-module 修改文件 ～/.config/gtk-3.0/settings.ini ，[Settings] 条目下 添加 gtk-modules=appmenu-gtk-module apt 安装 appmenu-qt appmenu-gtk2-module appmenu-gtk3-module libdbusmenu-gtk3-4 libdbusmenu-gtk4 libdbusmenu-qt5-2 注销或重启  去除最大化窗口时的标题栏 在 ~/.config/kwinrc 添加配置： [Windows] BorderlessMaximizedWindows=true 然后重新登录\n插件 将插件复制到 ~/.local/lib/dde-top-panel/plugins 下\nde-istate-menus 下载release\n3.0版本只兼容部分英特尔cpu，如果崩溃，请使用2.0版本\n 需要安装新依赖：libsensors5 确保执行过 sensors-detect，且 sensors 有输出。 需要重新设置权限 功耗只支持部分 Intel CPU，由于Linux上没有获取功耗的统一接口，导致该部分功能直接和硬件挂钩，很容易不兼容然后导致 top-panel 闪退。如有问题，请暂时使用 0.2 版本\n 安装依赖 1  sudo apt install libqt5charts5   给予权限 1  sudo setcap cap_net_raw,cap_dac_read_search,cap_sys_ptrace+ep \u0026lt;dde-top-panel的路径\u0026gt;   安装 将插件复制到~/.local/lib/dde-top-panel/plugins即可\n参考资料 septemberhx:dde-top-panel\nseptemberhx:dde-istate-menus\ngithub:dde-top-panel\n","date":"2021-02-11T00:00:00Z","image":"https://s3.ax1x.com/2021/01/31/yA4cJs.jpg","permalink":"https://gbwater.ga/p/deepin20%E7%BC%96%E8%AF%91%E5%AE%89%E8%A3%85dde-top-panel/","title":"deepin20编译安装dde-top-panel"},{"content":"deepin入坑指南(前言)——简介与说明 什么是deepin？  deepin（原名：Linux Deepin；中文通称：深度操作系统）是由武汉深之度科技有限公司在Debian基础上开发的Linux操作系统，其前身是Hiweed Linux操作系统，于2004年2月28日开始对外发行，可以安装在个人计算机和服务器中\n​\t——来自百度百科\n 提到deepin，你是不是想到了这个：\n事实上，深度（即deepin）以前和雨林木风、番茄花园一样，是做盗版系统的。但是，深度的盗版Windows的最后一版是XP V9.0。自2009年，HiweedLinux改名deepin，自此，Deepin的历史开始了。\n这就是我的Deepin桌面：\n\n安装Deepin之前 在安装Deepin之前，首先要明确，Deepin不是Windows。请务必了解以下内容：\nDeepin和Windows有什么不同  Deepin的软件包格式为.deb和.AppImage，exe程序在Deepin下不一定能完美运行 Deepin中占用的文件可以直接删除，而Windows不能 Deepin的权限较Windows更高，随意使用有破坏系统的风险 Deepin的文件系统为ext4，Windows不能访问，Deepin可以访问NTFS，但稍微缓慢 Deepin自定义可以更加彻底，使用更自由 \u0026hellip;\u0026hellip;  Deepin能做什么  QQ、微信（使用deepin-wine运行的Windows程序） 轻度的视频剪辑 主流的音乐播放（网易云音乐，QQ音乐） 轻度的游戏（Steam、HMCL启动的MC，但很多游戏没有Linux版本） 下载器（迅雷等） 网盘（百度网盘等） 基本的CAD软件 其他基本需求（浏览器、播放器、开发工具等） \u0026hellip;\u0026hellip;  谁适合使用  Deepin下日常办公完全适合 银行系统大多只能用IE浏览器，无法在Deepin上安装 重度游戏爱好者建议上游戏官网查看有没有Linux版本后决定 CAD软件不是特别完善 对只有Windows版本的软件重度依赖的人不建议使用  需要做好的准备  备份好重要文件 请不要把Windows下的习惯带到Deepin，尝试适应它 一个Deepin论坛帐号，遇到问题时发帖求助 下载Deepin系统镜像 一只8G以上的U盘（用于系统安装） 看完这篇文章（皮） 一个准备应对困难的好心情  Linux基本知识简介 在这个部分，你将学到基本的Linux知识，能更快的适应Deepin，要坚持看完哦~\n文件目录 目录就是文件夹（省了一个字，嘿嘿）。目录的表示方法是：\n 以/开头 两层文件夹之间用/隔开  如：\n1  /home/gbwater/Desktop/   表示的就是home里的gbwater文件夹里的Desktop文件夹，即桌面。这一串东西叫路径。这和Windows很相似。\n根目录 不同于Windows，Deepin没有盘符，更没有C盘。请不要因此抱怨，这更加科学和便利。\nDeepin的系统存放在根目录（/），下图的“系统盘”指的就是根目录\n\n所有的其他主要目录（home、opt、usr等，将在下文介绍）都挂载（类似Windows下的快捷方式）在根目录。所以选择文件夹时找不到这些文件夹，那就去根目录里找。虽然你有权限，但不要轻易修改里面的内容，容易使系统崩溃。\n进入根目录有两种方式，一是在文件管理器中双击进入，而是在终端下使用命令（详情请见后文的终端部分）：\n1  cd /   /home /home目录就是文件管理器侧边栏的“主目录”，是储存用户文件的目录。“桌面”、“文档”、“下载”等文件夹都存在这个目录，如图所示:\n\n但千万不要认为这里面只有用户文件，许多重要的配置文件也储存在这里。要查看或修改这些文件，需要临时显示隐藏文件，快捷键：ctrl+H，再次进入时会默认隐藏。\n要在终端进入/home，输入命令：\n1  cd ~/   /opt /opt是存放软件的目录。按照Deepin的规范，所有在应用商店里安装的软件都会存放到/opt/apps下一个以软件包（将在下文介绍）名称命名的文件夹下。这很类似Windows中C盘下的“programme files”文件夹。如果不是在应用商店里安装的，一般默认直接安装到/opt。如图所示：\n\n/media  linux 系统会自动识别一些设备，例如U盘、光驱等等，当识别后，Linux 会把识别的设备挂载到这个目录下。\n 比如我的用户名是gbwater，那么新插入的U盘就在/media/gbwater下能找到。当然，要访问U盘等设备直接一打开文件管理器就能看到了。\n/usr usr 是 unix shared resources(共享资源) 的缩写，这是一个非常重要的目录，用户的很多应用程序和文件都放在这个目录下，类似于 windows 下的 program files 目录。\n小结 Linux下的系统目录还有很多，这里介绍的都是比较常用的。所有这些目录都挂载在根目录下面。建议安装系统的时候将一些重要的目录单独分区，而不是让它们默认地储存到根目录。这样，重装系统时只要选择挂载它们，数据什么的都不会丢。这是Linux区别于Windows的一大特点。\n软件包简介 软件包就是软件。Deepin中软件的安装包一般是.deb格式。\n依赖关系 软件包之间可以有依赖关系。所谓依赖关系，就是安装的顺序。如A依赖B，那么安装A时一定要先安装B，卸载B时也会一起卸载A\n基本的命令行操作 很多人谈命令行色变，认为命令行是程序员的玩物。其实并不是，命令行是操作的一种方式，有时候比在图形界面用鼠标点更方便快捷，还能完成一些图形界面不能实现的操作。\n运行命令需要终端，如图所示：\n\n运行命令时，在里面输入命令，然后按回车键即可\n深度终端使用简介  用鼠标按住并拖动选择内容 复制文字快捷键ctrl+shift+C i粘贴文字快捷键ctrl+shift+V 终止当前程序运行快捷键ctrl+C  当然，你也可以选中内容然后在要插入的地方单击鼠标中键将其插入\n什么是命令 一个命令其实就是一个软件，存放在/bin目录下。\n有的命令不用参数，有的命令需要参数。参数就是告诉这个命令要它做什么。参数直接跟在命令后面。\n参数的形式不是固定的，下面将简单介绍一些常用的命令。\n权限获取 Linux下root的权限是系统的最高权限，可以进行任意操作（甚至删掉整个系统！）。\n一些操作比如修改系统文件，安装软件之类的操作需要root权限。\n要临时用root权限执行命令，在命令前加上“sudo”，回车后输入密码。注意在终端输入密码是不会显示你输入了什么的。输入完成后再回车即可。在同一个终端窗口中第二次使用sudo是不用输入密码的。\n例如，要临时用root权限安装软件，输入：\n1  sudo apt install \u0026lt;软件包名称\u0026gt;   下文都会使用\u0026quot;\u0026lt;\u0026gt;\u0026ldquo;表示需要替换的内容\n要在当前终端窗口中启用root，输入命令：\n1  su   回车后输入密码即可。\n要退出root，输入命令:\n1  exit   文件、目录操作 还没有输入命令时，光标前面有一行字，比如：\n1  gbwater@gbwater-PC:~/Desktop$   此处gbwater指的是当前窗口中登录的用户名，用su命令进入root后会显示：\n1  root@gbwater-PC:/home/gbwater/Desktop#   冒号后面到$或#前面是当前所处的目录位置，如当前就处于~/Desktop下\n要进入当前目录里的一个文件夹，输入\n1  cd \u0026lt;文件夹名称\u0026gt;   要返回上一目录，输入：\n1  cd ..   \u0026ldquo;..\u0026ldquo;其实是一个文件夹，进入它就是进入上一目录\n要查看当前目录下有什么文件（夹），输入：\n1  ls   这条命令默认不显示隐藏文件（夹），要连带隐藏文件（夹）一起查看，输入：\n1  ls -a   如果嫌文件或者文件夹名字太长，可以按tap让终端帮你自动补全。\ncd命令也可以进入不在当前文件夹的目录，输入;\n1  cd \u0026lt;目录的路径\u0026gt;   如果路径中含有空格，需要将路径用单引号括起来。当然，你也可以直接在文件管理器里将那个文件(夹)拖到终端里。\n新建文件夹，输入：\n1  mkdir \u0026lt;文件夹名称\u0026gt;   删除文件，输入：\n1  rm \u0026lt;文件路径\u0026gt;   如果要删除的文件位于当前目录，可以直接输入文件名称\n注意在终端中删除的文件不能在回收站中恢复！\n删除文件夹，输入：\n1  rm -r \u0026lt;文件夹路径\u0026gt;   如果要删除的文件夹位于当前目录，可以直接输入文件夹名称\n不想看到确认删除的提示，加上-f：\n1  rm -rf \u0026lt;要删的东西\u0026gt;   复制文件：\n1  cp \u0026lt;要复制的东西\u0026gt; \u0026lt;复制去的目录\u0026gt;   注意复制去的目录后面要加上斜杠（/）\n移动文件：\n1  mv \u0026lt;要移动的东西\u0026gt; \u0026lt;移动去的目录\u0026gt;   注意移动去的目录后面要加上斜杠（/）\n重命名文件（夹）：\n1  mv \u0026lt;原名\u0026gt; \u0026lt;新名称\u0026gt;   注意如果重命名的是文件夹，后面不能加上斜杠（/）！\n软件包操作 在线安装软件包\n1  sudo apt install \u0026lt;软件包名称\u0026gt;   安装下载的软件包（自动处理依赖关系）\n1  sudo apt install \u0026lt;软件包文件的路径\u0026gt;   安装下载的软件包（不自动处理依赖关系）\n1  sudo dpkg -i \u0026lt;软件包文件的路径\u0026gt;   自动修复依赖关系\n1  sudo apt install -f   在线搜索软件包\n1  apt search \u0026lt;软件包名称\u0026gt;   下载软件包\n1  apt download \u0026lt;软件包名称\u0026gt;   删除软件包(保留其配置文件)\n1  sudo apt remove \u0026lt;软件包名称\u0026gt;   删除软件包(删除其配置文件)\n1  sudo apt purge \u0026lt;软件包名称\u0026gt;   当然，以上操作可以通过deepin软件包管理器及起动器的右键菜单以图形界面的方式完成。\n尾声 相信看完了以上内容，你对Deepin和Linux的了解更深入了。在实体机安装之前，不如先用虚拟机体验一下。欢迎使用！\n参考资料 Deepin入门指南系列（一）：你好 deepin\nLinux 系统目录结构\n","date":"2021-02-11T00:00:00Z","image":"https://s3.ax1x.com/2021/01/31/yA4cJs.jpg","permalink":"https://gbwater.ga/p/deepin%E5%85%A5%E5%9D%91%E6%8C%87%E5%8D%97%E5%89%8D%E8%A8%80%E7%AE%80%E4%BB%8B%E4%B8%8E%E8%AF%B4%E6%98%8E/","title":"deepin入坑指南(前言)——简介与说明"},{"content":"csp2020小结 初试 众所周知，参加csp/NOIP系列比赛最不稳的就是初试，有时候准备了一年多结果初试没过，功亏一篑。\n这一次赛前对于初试的准备较少，记得考csp2019前我还是把《信息学奥赛一本通——初赛篇》看了一遍的\t记得NOIP2018也是这么干的 。u1s1，这本书写的还是很好的，初赛的很多内容都有涵盖到，但是时间复杂度计算这一块没有，需要额外补充。\n点击查看csp-s1试题\n选择题  全都化成二进制就好比较就行了 送分题 一张图片大小s：$2048\\times 1024 \\times 32 \\div 8 = 8388608 byte$ ,总大小：$s\\times 24\\times 8\\times 60 = 96,636,764,160byte= 90GB$ 模拟一下就行了 四个选项都代进去算一下，哪个不重复就是哪个 0-1背包经典的动规，送分题 邻接表建图必须，OIer肯定都会 $12\\times 12 = 144$,注意不用除以2 写过的都会 反正我是全列出来一个一个消的 等差数列求和,注意区间就可以了 括号法:$a*(b+c)-d \\rightarrow (a*(b+c))-d \\rightarrow (a(bc+)*)d- \\rightarrow abc+*d-$ 当然画表达式树也行 基本常识，送分题  阅读程序    n等于1000不会越界，注意题中是$\u0026lt;$ 而不是$\u0026lt;=$ n可以是-1，当然不一定 将i和j互换，$d[i]+d[j]-(d[i] \u0026amp; d[j])$的值不改变，结果当然也不会改变 也是将i和j互换，只要不等于就会执行下方语句，结果当然不改变 化为二进制判断一下其实是我懒得写 只用管二进制的最后一位就行了，奇数二进制的最后一位是1，偶数是0，按选项推一下就行了其实是我懒得写   不会，瞎蒙的，好像错了很多QAQ 一看就令人懵逼，我怎么可能会呢，好像蒙错了很多QAQ  完善程序     此处就是因为整数除法有精度问题才用乘法的，后面的语句有提示，变形一下就有了。但是为什么我在比赛的时候没有意识到呢QAQ\n  看着后面else里的应该知道选啥了吧？    此处依然和（1）一样，为了精度改用乘法\n  体积比B小，直接全部都要！但为什么我又错了QAQ\n    这种题，怎么会做呢？我用上下文对称做法，结果又错了一堆QAQ\n  总结 总的来说，选择题比较容易，大题比较难。但是我错了很多能对的题，可能主要是因为看到会做太兴奋了QAQ\n而且完善程序不是用对称法就能做对的QAQ\n复试 前言 先来揭露一下圈钱组织的真面目：\n\n\n嗯，这转折，绝了。\n一些准备 本来以为它要考很多dp，考前特地去练了很多，结果最后还是没有做出来QAQ\n由于csp2019考了很多树，我还特意去学了树剖，结果一个都没考QAQ\n不过，考前特地看了最快的快读。这次数据量这么大，总算有用了一次\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  #include\u0026lt;cstdio\u0026gt;#define ll long long ll read() { char c=getchar(); ll num=0; while(c\u0026gt;\u0026#39;9\u0026#39;||c\u0026lt;\u0026#39;0\u0026#39;) { c=getchar(); } while(c\u0026lt;=\u0026#39;9\u0026#39;\u0026amp;\u0026amp;c\u0026gt;=\u0026#39;0\u0026#39;) { num=(num\u0026lt;\u0026lt;1)+(num\u0026lt;\u0026lt;3)+(c^\u0026#39;0\u0026#39;); c=getchar(); } return num; }   还有，不要用cin！不要用cin！即便加了网传的奇淫技巧：\n1 2  ios::sync_with_stdio(0); cin.tie(0);   也没用！\n活生生的教训仍历历在目：\n用scanf的：\n\n用cin+上述“优化”的：\n\n真是一个令人悲桑的故事啊\nT1儒略日 这道题一看似曾相识，于是上来先推公式，无果，于是想想其他做法\n想了半天想不出来，于是暴力模拟！一天一天的往初始日期累加\n写了一个用来计算指定月份天数的函数，也就是判断闰年，然后返回\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19  int DayInMon(int y,int m) { bool r_year=false; if(y\u0026lt;0) { if((-(y+1))%4==0) r_year=true; } else if(y\u0026lt;1582) { if(y%4==0) r_year=true; } else { if(y%4==0\u0026amp;\u0026amp;(y%400==0||y%100!=0)) r_year=true; } if(m==2) return r_year? 29:28; if(m\u0026lt;=7) return m%2==0? 30:31; else return m%2==0? 31:30; }   然后又写了一个日期加一的函数，就是如果天数到头月+1，年份到头年+1。然后特判年份为-1时下一年为1：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22  void add() { if(day\u0026lt;DayInMon(year,month)) { day++; } else { if(month\u0026lt;12) { month++; day=1; } else { if(year==-1) year++; year++; month=1; day=1; } } }   但是看到数据范围，O(Qr)的复杂度肯定爆啊\n于是想着优化\n优化1：既然一天一天加慢，那我一个月一个月加不就好了？\n然而，由于要考虑的特殊情况太多，像什么闰不闰年，哪天被删了之类的，头疼。。。。。。\n打了半天样例都没过，一瞥旁边的那位兄台，人家都开始打T2了！\n好家伙，不打了，换！\n优化2：一看80%数据范围：$Q=10^5,r_i\u0026lt;=10^7$！想到了啥？离线处理！\n何为离线处理？就是一个对于多询问的优化方法，将所有询问由小到大排个序并记录原始顺序（毕竟输出还要按照原来的顺序输出），从头开始，遇到就记录答案，最后按原来的顺序输出。\n打完心里美滋滋，想着80分稳了分不在多，及格就行~\n完整代码如下：\n一个模拟打这么多行我也是醉了\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120  #include\u0026lt;cstdio\u0026gt;#include\u0026lt;algorithm\u0026gt;#define ll long long using namespace std; ll read() { char c=getchar(); ll num=0; while(c\u0026gt;\u0026#39;9\u0026#39;||c\u0026lt;\u0026#39;0\u0026#39;) { c=getchar(); } while(c\u0026lt;=\u0026#39;9\u0026#39;\u0026amp;\u0026amp;c\u0026gt;=\u0026#39;0\u0026#39;) { num=(num\u0026lt;\u0026lt;1)+(num\u0026lt;\u0026lt;3)+(c^\u0026#39;0\u0026#39;); c=getchar(); } return num; } ll year=-4713,month=1,day=1; int DayInMon(int y,int m) { bool r_year=false; if(y\u0026lt;0) { if((-(y+1))%4==0) r_year=true; } else if(y\u0026lt;1582) { if(y%4==0) r_year=true; } else { if(y%4==0\u0026amp;\u0026amp;(y%400==0||y%100!=0)) r_year=true; } if(m==2) return r_year? 29:28; if(m\u0026lt;=7) return m%2==0? 30:31; else return m%2==0? 31:30; } void add() { if(day\u0026lt;DayInMon(year,month)) { day++; } else { if(month\u0026lt;12) { month++; day=1; } else { if(year==-1) year++; year++; month=1; day=1; } } } ll Ayear[100010],Amonth[100010],Aday[100010]; struct que { ll rnk; ll date; }q[100010]; bool cmp(que a,que b) { return a.date\u0026lt;b.date; } int main() { freopen(\u0026#34;julian.in\u0026#34;,\u0026#34;r\u0026#34;,stdin); freopen(\u0026#34;julian.out\u0026#34;,\u0026#34;w\u0026#34;,stdout); ll T=read(); ll maxon=0; for(ll i=1;i\u0026lt;=T;i++) { q[i].date=read(); q[i].rnk=i; if(maxon\u0026lt;q[i].date) maxon=q[i].date; } ll da=0; sort(q,q+T,cmp); ll cnt=1; ll lu=maxon; while(lu) { da++; if(year==1582\u0026amp;\u0026amp;month==10\u0026amp;\u0026amp;day==4) { lu--; day=15; } else { add(); lu--; } while(da==q[cnt].date) { Ayear[q[cnt].rnk]=year; Amonth[q[cnt].rnk]=month; Aday[q[cnt].rnk]=day; cnt++; } }\tfor(int i=1;i\u0026lt;=T;i++) { if(Ayear[i]\u0026lt;0) printf(\u0026#34;%lld %lld %lld\u0026#34;,Aday[i],Amonth[i],-Ayear[i]); else printf(\u0026#34;%lld %lld %lld\u0026#34;,Aday[i],Amonth[i],Ayear[i]); if(year\u0026lt;0) printf(\u0026#34; BC\u0026#34;); putchar(\u0026#39;\\n\u0026#39;); } fclose(stdin); fclose(stdout); return 0; }   等到出成绩，我人都傻了，好家伙，爆零！\n回来交了洛谷，才发现犯了3个致命的错误\n注意第101行：\n1 2 3 4 5 6 7  while(da==q[cnt].date) { Ayear[q[cnt].rnk]=year; Amonth[q[cnt].rnk]=month; Aday[q[cnt].rnk]=day; cnt++; }   这里我之前写的是：\n1 2 3 4 5 6 7  if(da==q[cnt].date) { Ayear[q[cnt].rnk]=year; Amonth[q[cnt].rnk]=month; Aday[q[cnt].rnk]=day; cnt++; }   当有询问是重复的时候就会引起错误！\n幸好我最后检查的时候把它改过来了。\n但是！注意第85行：\n1  sort(q,q+T,cmp);   明明应该是下面这个好不好！\n1  sort(q,q+T+1,cmp);   这是个遗留问题，因为我之前的输入写的是：\n1 2 3 4 5 6  for(ll i=0;i\u0026lt;T;i++) { q[i].date=read(); q[i].rnk=i; if(maxon\u0026lt;q[i].date) maxon=q[i].date; }   但是我改了读入没改sort！于是。。。。。。爆零快乐QAQ\n除此之外，注意第114行：\n1  if(year\u0026lt;0) printf(\u0026#34; BC\u0026#34;);   乍一看好像没问题，但是！我存年份明明用的是Ayear[i]啊。。。\n这输出明显要么全部带BC，要么不带BC，这不爆零谁爆零？\n但是，这么明显我为什么没发现呢？看看样例：\n 3 10 100 1000   11 1 4713 BC 10 4 4713 BC 27 9 4711 BC   3 2000000 3000000 4000000   14 9 763 15 8 3501 12 7 6239  好家伙，样例里要么都是带BC的，要么都是不带BC的！CCF老坑批了。。。\n还有，注意我写的while循环：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21  while(lu) { da++; if(year==1582\u0026amp;\u0026amp;month==10\u0026amp;\u0026amp;day==4) { lu--; day=15; } else { add(); lu--; } while(da==q[cnt].date) { Ayear[q[cnt].rnk]=year; Amonth[q[cnt].rnk]=month; Aday[q[cnt].rnk]=day; cnt++; } }   好家伙，我竟然没有意识到输入会有0！这样若遇到0，啥都不会输出！真是快乐\n80-\u0026gt;0 ！另附修正后的80分代码：(什么？你说丑，那是dev太烂了QAQ)\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127  #include\u0026lt;cstdio\u0026gt;#include\u0026lt;algorithm\u0026gt;#define ll long long using namespace std; ll read() { char c=getchar(); ll num=0; while(c\u0026gt;\u0026#39;9\u0026#39;||c\u0026lt;\u0026#39;0\u0026#39;) { c=getchar(); } while(c\u0026lt;=\u0026#39;9\u0026#39;\u0026amp;\u0026amp;c\u0026gt;=\u0026#39;0\u0026#39;) { num=(num\u0026lt;\u0026lt;1)+(num\u0026lt;\u0026lt;3)+(c^\u0026#39;0\u0026#39;); c=getchar(); } return num; } ll year=-4713,month=1,day=1; int DayInMon(int y,int m) { bool r_year=false; if(y\u0026lt;0) { if((-(y+1))%4==0) r_year=true; } else if(y\u0026lt;1582) { if(y%4==0) r_year=true; } else { if(y%4==0\u0026amp;\u0026amp;(y%400==0||y%100!=0)) r_year=true; } if(m==2) return r_year? 29:28; if(m\u0026lt;=7) return m%2==0? 30:31; else return m%2==0? 31:30; } void add() { if(day\u0026lt;DayInMon(year,month)) { day++; } else { if(month\u0026lt;12) { month++; day=1; } else { if(year==-1) year++; year++; month=1; day=1; } } } ll Ayear[100010],Amonth[100010],Aday[100010]; struct que { ll rnk; ll date; }q[100010]; bool cmp(que a,que b) { return a.date\u0026lt;b.date; } int main() { freopen(\u0026#34;julian.in\u0026#34;,\u0026#34;r\u0026#34;,stdin); freopen(\u0026#34;julian.out\u0026#34;,\u0026#34;w\u0026#34;,stdout); ll T=read(); ll maxon=0; for(ll i=1;i\u0026lt;=T;i++) { q[i].date=read(); q[i].rnk=i; if(maxon\u0026lt;q[i].date) maxon=q[i].date; } ll da=0; sort(q+1,q+T+1,cmp); ll cnt=1; while(da==q[cnt].date) { Ayear[q[cnt].rnk]=year; Amonth[q[cnt].rnk]=month; Aday[q[cnt].rnk]=day; cnt++; } ll lu=maxon; while(lu) { da++; if(year==1582\u0026amp;\u0026amp;month==10\u0026amp;\u0026amp;day==4) { lu--; day=15; } else { add(); lu--; } while(da==q[cnt].date) { Ayear[q[cnt].rnk]=year; Amonth[q[cnt].rnk]=month; Aday[q[cnt].rnk]=day; cnt++; } }\tfor(int i=1;i\u0026lt;=T;i++) { if(Ayear[i]\u0026lt;0) printf(\u0026#34;%lld %lld %lld\u0026#34;,Aday[i],Amonth[i],-Ayear[i]); else printf(\u0026#34;%lld %lld %lld\u0026#34;,Aday[i],Amonth[i],Ayear[i]); if(Ayear[i]\u0026lt;0) printf(\u0026#34; BC\u0026#34;); putchar(\u0026#39;\\n\u0026#39;); } fclose(stdin); fclose(stdout); return 0; }   T2动物园 写完T1，赶紧来写T2（T1就打了1个多小时QAQ）\n题意很简单，就是一个二进制的题，我很快就写出了代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56  #include\u0026lt;cstdio\u0026gt;#include\u0026lt;algorithm\u0026gt;#include\u0026lt;set\u0026gt;#define ll long long using namespace std; ll read() { char c=getchar(); ll num=0; while(c\u0026gt;\u0026#39;9\u0026#39;||c\u0026lt;\u0026#39;0\u0026#39;) { c=getchar(); } while(c\u0026lt;=\u0026#39;9\u0026#39;\u0026amp;\u0026amp;c\u0026gt;=\u0026#39;0\u0026#39;) { num=(num\u0026lt;\u0026lt;1)+(num\u0026lt;\u0026lt;3)+(c^\u0026#39;0\u0026#39;); c=getchar(); } return num; } int A[1000010]; int q[1000010],p[1000010]; ll cnt=0; set \u0026lt;ll\u0026gt; cannot; int main() { freopen(\u0026#34;zoo.in\u0026#34;,\u0026#34;r\u0026#34;,stdin); freopen(\u0026#34;zoo.out\u0026#34;,\u0026#34;w\u0026#34;,stdout); ll n=read(),m=read(),c=read(),k=read(); for(int i=0;i\u0026lt;n;i++) A[i]=read(); for(int i=0;i\u0026lt;m;i++) { p[i]=read(); q[i]=read(); } for(int i=0;i\u0026lt;m;i++) { bool flag=false; for(int j=0;j\u0026lt;n;j++) { if(A[j]\u0026amp;(1\u0026lt;\u0026lt;(p[i]))) { flag=true; } } if(!flag\u0026amp;\u0026amp;cannot.find(1\u0026lt;\u0026lt;(p[i]))==cannot.end()) { cnt++; cannot.insert(1\u0026lt;\u0026lt;(p[i])); } } printf(\u0026#34;%lld\u0026#34;,(1\u0026lt;\u0026lt;(k-cnt))-n); fclose(stdin); fclose(stdout); return 0; }   不到半个小时就写完了，心里想着A了A了就去看T3了。\n但是！可能是写的太快，我并没有意识到n,m都是小于$10^6$\n并且输出可以是$2^{64}$爆long long\n要知道，只要建一个变量把A数组全部按位或就可以把内层循环去掉了，然后再改一下输出就能A了QAQ\n100-\u0026gt;60！T3调用 看到此题，我心中狂喜，这不就是线段树裸题吗？丝毫没有注意到数据范围\n于是打了一遍板子，过了前两个样例，想着A了A了就走了丝毫没有意识到问题的严重性\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196  #include\u0026lt;cstdio\u0026gt;#include\u0026lt;algorithm\u0026gt;#include\u0026lt;vector\u0026gt;#define ll long long #define mod 998244353 using namespace std; ll read() { char c=getchar(); ll num=0; while(c\u0026gt;\u0026#39;9\u0026#39;||c\u0026lt;\u0026#39;0\u0026#39;) { c=getchar(); } while(c\u0026lt;=\u0026#39;9\u0026#39;\u0026amp;\u0026amp;c\u0026gt;=\u0026#39;0\u0026#39;) { num=(num\u0026lt;\u0026lt;1)+(num\u0026lt;\u0026lt;3)+(c^\u0026#39;0\u0026#39;); c=getchar(); } return num; } #define ls (p\u0026lt;\u0026lt;1) #define rs (ls|1) #define mid (ln[p]+rn[p]\u0026gt;\u0026gt;1) int num[100010],ln[400010],rn[400010]; ll la[400010],lm[400010]; ll dat[400010]; int mx; void build(int p,int l,int r) { mx=max(mx,p); ln[p]=l;rn[p]=r; lm[p]=1; if(l==r) { dat[p]=num[l]; return; } build(ls,l,mid); build(rs,mid+1,r); } void down(int p) { if(ln[p]==rn[p]) return; if(ln[ls]==rn[ls]) { if(lm[p]!=1) { dat[ls]*=lm[p]; } if(la[p]) { dat[ls]+=la[p]; } dat[ls]%=mod; } else { la[ls]*=lm[p]; lm[ls]*=lm[p]; la[ls]+=la[p]; la[ls]%=mod; } if(ln[rs]==rn[rs]) { if(lm[p]!=1) { dat[rs]*=lm[p]; } if(la[p]) { dat[rs]+=la[p]; } dat[rs]%=mod; } else { la[rs]*=lm[p]; lm[rs]*=lm[p]; la[rs]+=la[p]; la[rs]%=mod; } lm[p]=1;la[p]=0; } void add(int p,int pos,int v) { if(ln[p]==rn[p]) { dat[p]+=v; return; } down(p); if(pos\u0026lt;=mid) add(ls,pos,v); else add(rs,pos,v); } void mut(int v) { la[1]*=v; lm[1]*=v; } void out(int p) { if(ln[p]==rn[p]) { printf(\u0026#34;%lld \u0026#34;,dat[p]%mod); return; } down(p); out(ls); out(rs); } struct fun { int cla; int p,v; int tot; vector \u0026lt;int\u0026gt; fl; }F[100010]; void run(int rnk) { switch(F[rnk].cla) { case 1: { add(1,F[rnk].p,F[rnk].v); break; } case 2: { mut(F[rnk].v); break; } case 3: { for(int i=0;i\u0026lt;F[rnk].tot;i++) { run(F[rnk].fl[i]); } } } } int FUN[100010]; int main() { freopen(\u0026#34;call.in\u0026#34;,\u0026#34;r\u0026#34;,stdin); freopen(\u0026#34;call.out\u0026#34;,\u0026#34;w\u0026#34;,stdout); int n=read(); for(int i=1;i\u0026lt;=n;i++) { num[i]=read(); } build(1,1,n); int m=read(); for(int i=1;i\u0026lt;=m;i++) { int t=read(); F[i].cla=t; switch(t) { case 1: { int p=read(),v=read(); F[i].p=p;F[i].v=v; break; } case 2: { int v=read(); F[i].v=v; break; } case 3: { int c=read(); F[i].tot=c; for(int j=0;j\u0026lt;c;j++) { F[i].fl.push_back(read()); } } } } int Q=read(); for(int i=0;i\u0026lt;Q;i++) { FUN[i]=read(); } for(int i=0;i\u0026lt;Q;i++) { run(FUN[i]); } out(1); fclose(stdin); fclose(stdout); return 0; }   而且！因为我忘记了乘法能不能直接取模，于是我就没给乘法取模，样例3 long long乘爆了输出全是0！\n更严重的是，这份线段树打挂了，至今都没调处来哪里挂了\n交了份官方数据，发现只有三分之一的数据是TLE的\n凉了凉了。。。。。。不过这还有10分？\nT4贪吃蛇 我看到这题我就知道不会做，更何况到这里只剩半个小时了，放弃，回去检查了。\n总结 总的来说，这次复试存在重大失误，只剩70了，估计水个三等都难QAQ\n好像比去年好？但这我拿不到奖有什么关系？\n不过还有NOIP\t真·有分就行\n\n","date":"2020-11-22T00:00:00Z","image":"https://s3.ax1x.com/2020/11/22/D3BGc9.jpg","permalink":"https://gbwater.ga/p/csp2020%E5%B0%8F%E7%BB%93/","title":"csp2020小结"},{"content":"简介  实现Windows下根据时间表自动将指定目录中的文件备份到指定目录 说白了就是根据课程表将课件分类复制到各科目对应的文件夹(需要指定) 可选预先扫描目标文件夹以跳过重复文件 可选保存文件信息以减少扫描时间(就是复制过的课件不再复制) 可选彻底排除重复文件(就是即使有两个没复制过的但仅文件名不同的课件也只会复制其中一个) 性能优化，cpu占用低于1%(环境: Intel core i7-3820@3.6G × 4) 支持排除文件(可以指定不复制的文件,比如桌面上的一堆lnk之类) \u0026hellip;\u0026hellip;  v 2.6.1更新内容  修复了Windows7下不能成功读取课程表的问题 修复了科目切换的问题 移除日志中移除空文件夹的输出  使用说明  下载后编辑settings.txt完成时间配置 在程序所在目录下建立时间表：星期一：1.txt 星期二：2.txt ……以此类推 完成时间表的配置 运行start.vbs 在指定的文件夹中查看文件  特别说明   时间表填写可以不按照时间顺序，使用24小时制，一个一行，不能有空行\n  周天对应的时间表是0.txt\n  时间表填写格式：起始时间 终止时间 文件夹名称\n  例：7:10 到 8:10 有一节语文课，应写入：\n 7 10 8 10 语文\n   目前文件夹快捷选择仅支持桌面，如需使用使用，在文件源处填写：Desktop\n  程序文件在：build-automatic_files_backup-Desktop_Qt_5_14_2_MinGW_32_bit-Release 中的 release 文件夹\n  请把 release 文件夹完整下载使用，里面的文件都很重要，否则程序将无法运行\n  build-automatic_files_backup-Desktop_Qt_5_14_2_MinGW_32_bit-Debug 文件夹中是调试用的文件\n  automatic_files_backup 文件夹中是程序源代码\n  请不要直接运行 automatic_files_backup.exe ，除非你想看见一个大黑框\n  settings.txt中排除的文件处请随便填一个，否则不能读取成功\n  配置文件仅支持utf-8编码，如果您不知道什么是utf-8,请直接修改配置模板和settings而非自己创建文本文件\n  填写示例 配置文件：settings.txt  #注释以‘#’开头，一个一行\n#文件源\nJ:/Application software/tools/DIY tools/文件自动保存/1.1\n#目标目录\nC:/Users/32154/Desktop/新建文件夹 (2)\n#等待时间，单位为毫秒\n10000\n#文件夹更新检测模式：1按照包含文件哈希值处理(更新及时，占用资源较大) 2按照文件夹修改时间处理(只有文件夹添加或删除文件时才会更新文件，占用资源较少)\n1\n#复制前扫描目标文件夹以保证不复制任何重复文件：1是 2否（占用资源较大，慎选！！！）\n1\n#使用预先保存的哈希文件代替扫描目标文件夹：1是 2否（每次复制或扫描文件都保存其哈希信息替代扫描目标文件夹，若需更新哈希信息，将hash.txt删除即可）\n1\n#排除的文件（夹），一行一个（不可使用通配符）\nxxx.lnk\nyyy.lnk\n数学\n 课程表：1.txt 21 10 22 03 语文\n22 03 23 00 数学\n8 59 9 20 英语\n下载链接 github release 直接点击下载\n未来规划更新内容  添加对通配符的支持 双哈希验证  项目地址 gtihub\n","date":"2020-11-22T00:00:00Z","image":"https://s3.ax1x.com/2020/11/22/D3b01J.jpg","permalink":"https://gbwater.ga/p/%E6%96%87%E4%BB%B6%E8%87%AA%E5%8A%A8%E4%BF%9D%E5%AD%98update2-6-1/","title":"文件自动保存update2-6-1"},{"content":"倍增LCA 引子 什么？你还不知道什么是LCA？LCA就是树上两个节点的最近公共祖先。\n所以，对于怎么找LCA，是个人都会想到一个办法，让两个节点不断向上移动，只要重合了就是LCA了，嘿嘿嘿\n然鹅，一个一个移动太慢，只要数据过了 $10^8$ 分分钟 T 飞~\n所以，我们需要一个快速的移动方式，比如，成几何级数的移动，这就是倍增算法\n基本思路 既然要成几何级数的移动速度，要找个底数，比如2吧，每次移动 $2^k$ 个\n要想一次移动这么多，肯定要预处理，不如先预处理一个数组 $grand[i][j]$ 表示 $i$ 向上跳$$2^k$$个是谁，跳出这棵树的值就为-1吧\n怎么判断已经跳到了LCA呢？毕竟公共祖先不只有LCA一个\n不如就不直接跳到LCA，把所有跳到相同节点的情况都视为跳出树了，一直跳直到跳不动了为止，这时候两个节点的父节点就是LCA了，是不是特别机智~\n预处理 怎么预处理出 $grand$数组呢？ 什么？你想一个个往上跳，然后取对数？省省吧，有这功夫早就 T 飞了，我们需要一个更高效的方法，最好能利用已经求出的 $grand$ 数组\n那不就是动态规划嘛，让我们来凑一手状态转移方程\n首先，$i$ 向上跳 $2^k$ 个可以分解成两个动作，先向上跳 $2^{k-1}$ 个，再向上跳 $2^{k-1}$ 个\n$i$向上跳 $2^{k-1}$ 个不就是$grand[i][k-1]$嘛，套个娃，再向上跳 $2^{k-1}$ 个当然就是 $grand[grand[i][k-1]][k-1]$ 。于是我们得出方程： $$ grand[i][k]=grand[grand[i][k-1]][k-1] $$ 瞅瞅这个方程，我们该用什么算法呢？\n要想转移状态，必须要先求出 $grand[i][k-1]$，这告诉我们应该：\n1 2 3 4  for(int k=;k\u0026lt; MAXON;k++) { //求grand }   再看，我们还要先求出$i$的祖先节点的$grand$，因为我们要用到$grand[grand[i][k-1]][k-1]$ 嘛，这好说，来一手 $dfs$ 深度优先搜索就好了，顺便还可以记录每个节点的父节点和深度，一举两得 于是我们竟然可以写出代码了 先用邻接表存图：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  struct edge { int to;//这条边到达的点 \tint next;//下一条边 \t}Edge[MAXON]; int head[MAXON];//head[i]表示由i开始的第一条边的编号 \tint tot=0;//总边数 \tint grand[500010][30]; int fa[MAXON]; void add_dege(int from, int to) { tot++;//当前边的编号 \tEdge[tot].to = to; if (from != -1) Edge[tot].next = head[from];//插入在前 \thead[from] = tot;//由于这条边插入在了前面,故当前边就是由from开始的第一条边 \t}   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25  void dfs(int from, int now) { fa[now] = from;//记录父节点 \tint start = head[now];//从第一个子节点开始找 \tif (from != -1)//若不是根节点,深度为父节点深度+1(根节点为0) \tdep[now] = dep[from] + 1; //int g = log2(dep[now]) ; \tint g = lg[dep[now]]; if (from != -1)//根节点没有父节点 \tgrand[now][0] = from;//2^0=1,即父节点 \tfor (int i = 1; i \u0026lt; = g; i++) { grand[now][i] = grand[grand[now][i - 1]][i - 1];//状态转移方程 \t} while (start)//一个一个找孩子 \t{ if (Edge[start].to == from)//若相连节点不是父节点 \t{ start = Edge[start].next; continue; } dfs(now, Edge[start].to);//继续搜索子节点 \tstart = Edge[start].next;//搜索下一个子节点 \t} }   跳！ 预处理好了，接下来就是跳了\n怎么跳呢？先跳到同一高度，然后什么都好说\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  if (dep[a] \u0026gt; dep[b])//统一b深度大于a \t{ a = a + b;//a此时等于原来的a,b之和 \tb = a - b;//b此时等于原来的a \ta = a - b;//a此时等于原来的b \t}//神奇的交换方法 \tint deep = dep[b] - dep[a];//深度差 \t//int step = log2(deep); \tint step = lg[deep];//最大要走的步数 \tfor (int i = step; i \u0026gt;= 0; i--)//先让b跳到和a同一深度 \t{ if (dep[grand[b][i]] \u0026lt; dep[a]) continue;//跳过头了,不跳 \telse { b = grand[b][i];//没跳过头,跳 \t} } if (a == b) return a;//若相等,则已经找到LCA   这里为什么要有个step呢，因为先封个顶，一点点下降，能跳再跳，万一就跳出去了呢\n然后就是两个节点一起向上跳了\n1 2 3 4 5 6 7 8 9 10 11 12  step = lg[dep[a]]; //要走的步数 \t//step = log2(dep[a]); \tfor (int i = step; i \u0026gt;= 0; i--) { if (grand[a][i] == grand[b][i]) continue;//跳过头了,不跳 \telse//没跳过头,跳 \t{ a = grand[a][i]; b = grand[b][i]; } } return fa[a];//最后他们的父节点就是LC   要问这个$lg$数组是怎么来的？洛谷上抄的，嘿嘿嘿\n1 2  for (int i = 1; i \u0026lt; = n; i++) //常数优化,预先算出log_2(i)+1的值，用的时候直接调用就可以了 \tlg[i] = lg[i - 1] + (1 \u0026lt;\u0026lt; lg[i - 1] == i); //看不懂的可以手推一下   完整代码 我写这玩意的时候特别喜欢class，于是。。。码风奇丑，凑合着看吧。。。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124  #include\u0026lt;cmath\u0026gt;#include\u0026lt;cstdio\u0026gt;#include\u0026lt;iostream\u0026gt;using namespace std; const int MAXON = 1000010; int dep[MAXON];//dep[i]代表编号为i的点所处的深度 int lg[MAXON]; class Graph { private: struct edge { int to;//这条边到达的点 \tint next;//下一条边 \t}Edge[MAXON]; int head[MAXON];//head[i]表示由i开始的第一条边的编号 \tint tot;//总边数 \tint grand[500010][30]; int fa[MAXON]; public: Graph() { tot = 0; } void add_dege(int from, int to) { tot++;//当前边的编号 \tEdge[tot].to = to; if (from != -1) Edge[tot].next = head[from];//插入在前 \thead[from] = tot;//由于这条边插入在了前面,故当前边就是由from开始的第一条边 \t} void dfs(int from, int now) { fa[now] = from;//记录父节点 \tint start = head[now];//从第一个子节点开始找 \tif (from != -1)//若不是根节点,深度为父节点深度+1(根节点为0) \tdep[now] = dep[from] + 1; //int g = log2(dep[now]) ; \tint g = lg[dep[now]]; if (from != -1)//根节点没有父节点 \tgrand[now][0] = from;//2^0=1,即父节点 \tfor (int i = 1; i \u0026lt;= g; i++) { grand[now][i] = grand[grand[now][i - 1]][i - 1];//状态转移方程 \t} while (start)//一个一个找孩子 \t{ if (Edge[start].to == from)//若相连节点不是父节点 \t{ start = Edge[start].next; continue; } dfs(now, Edge[start].to);//继续搜索子节点 \tstart = Edge[start].next;//搜索下一个子节点 \t} } int lca(int a, int b) { if (dep[a] \u0026gt; dep[b])//统一b深度大于a \t{ a = a + b;//a此时等于原来的a,b之和 \tb = a - b;//b此时等于原来的a \ta = a - b;//a此时等于原来的b \t}//神奇的交换方法 \tint deep = dep[b] - dep[a];//深度差 \t//int step = log2(deep); \tint step = lg[deep];//最大要走的步数 \tfor (int i = step; i \u0026gt;= 0; i--)//先让b跳到和a同一深度 \t{ if (dep[grand[b][i]] \u0026lt; dep[a]) continue;//跳过头了,不跳 \telse { b = grand[b][i];//没跳过头,跳 \t} } if (a == b) return a;//若相等,则已经找到LCA \tstep = lg[dep[a]]; //要走的步数 \t//step = log2(dep[a]); \tfor (int i = step; i \u0026gt;= 0; i--) { if (grand[a][i] == grand[b][i]) continue;//跳过头了,不跳 \telse//没跳过头,跳 \t{ a = grand[a][i]; b = grand[b][i]; } } return fa[a];//最后他们的父节点就是LCA \t} }; Graph G; int main() { int n, m, s; //cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m \u0026gt;\u0026gt; s; \tscanf(\u0026#34;%d%d%d\u0026#34;, \u0026amp;n, \u0026amp;m, \u0026amp;s); for (int i = 1; i \u0026lt;= n; i++) //常熟优化,预先算出log_2(i)+1的值，用的时候直接调用就可以了 \tlg[i] = lg[i - 1] + (1 \u0026lt;\u0026lt; lg[i - 1] == i); //看不懂的可以手推一下 \tn--; while (n--) { int a, b; //cin \u0026gt;\u0026gt; a \u0026gt;\u0026gt; b; \tscanf(\u0026#34;%d%d\u0026#34;, \u0026amp;a, \u0026amp;b); G.add_dege(a, b); G.add_dege(b, a); } G.dfs(-1, s); while (m--) { int a, b; //cin \u0026gt;\u0026gt; a \u0026gt;\u0026gt; b; \tscanf(\u0026#34;%d%d\u0026#34;, \u0026amp;a, \u0026amp;b); int ans = G.lca(a, b); if (ans == -1) printf(\u0026#34;%d\\n\u0026#34;, s); //cout \u0026lt;\u0026lt; s \u0026lt;\u0026lt; endl; \telse printf(\u0026#34;%d\\n\u0026#34;, ans); //cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; endl; \t} return 0; }   ","date":"2020-11-15T00:00:00Z","image":"https://s3.ax1x.com/2020/11/15/DPOB9J.jpg","permalink":"https://gbwater.ga/p/%E5%80%8D%E5%A2%9Elca/","title":"倍增LCA"},{"content":"简介 微软网盘SkyDrive已更名为OneDrive，在任何设备上可以随时使用OneDrive。在您的Windows电脑或Mac上都可以使用OneDrive，以在包括台式计算机、平板电脑和移动电话在内的所有常用设备上访问您的常用内容。将电脑上的重要文件与OneDrive.com保持同步。微软网盘OneDrive是管理与分享你的文档、照片和视频的最佳个人云存储服务，你几乎可以通过任何设备来访问这些文件——来自腾讯软件中心\n为什么选择onedrive?  不限速 空间大,5TB 与Windows结合完美,可以直接在文件管理器中访问、修改内容 具有同步盘的特性,所有修改在有网时自动保存到云端,添加文件只需将文件复制到onedrive对应文件夹中即可,所有设备多端同步 有网络时文件不需要下载即可访问,不占用本地空间 \u0026hellip;…  下载与安装 一般来说,Windows10默认安装了onedrive,安装Office(Microsoft365)也会默认安装。如果没有可以前往腾讯软件中心下载安装。 MAC理论上AppStore里有，如果没有，安装Office全家桶即可或者使用网页版 至于Linux\u0026hellip;\u0026hellip;真是一个令人悲伤的故事\u0026hellip;…\n登录与访问 如果已经安装并登录了账号，请按下面的步骤添加账号（可以共存）。如果没有，则跳过添加账号的步骤在弹出的窗口中直接输入账号密码登陆即可\n 左键单击任务栏上的onedrive图标  在弹出的窗口中左键单击设置  在菜单中点击设置  切换到\u0026quot;账户\u0026quot;标签,点击\u0026quot;添加账户\u0026quot;  在文本框中输入账号,点击登录  然后输入密码  随后可以修改文件夹保存位置,然后点击\u0026quot;下一步\u0026quot;  然后一路下一步,可以看看简介.移动应用各大应用商店里都有,不用在这里下载  最后即可在侧边栏打开onedrive文件夹以访问文件,此时所有内容不占用本地空间,有网络时即可访问.当然也可以下载,在要下载的文件(夹)上右键,选择对应操作即可   上传与同步 上传可以访问网页版进行操作，也可以直接在onedrive文件夹中操作，会自动同步到云端\n更多特性与操作 请访问微软官网获取\n","date":"2020-10-01T00:00:00Z","image":"https://s1.ax1x.com/2020/10/01/0McffA.jpg","permalink":"https://gbwater.ga/p/210-onedrive-%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/","title":"210 Onedrive 使用指南"},{"content":"这篇文章挺短的，因为我也不怎么会…(⊙_⊙;)…\n引子 众所周知，用导数可以求一个函数的最值\n如果\u0026hellip;要求的东西不是函数呢？\n比如： $$ a^2+b^2-2ab $$ 一般的做法肯定是均值不等式： $$ a^2+b^2-2ab \\ge 2ab-2ab =0 $$ 但如果复杂到均值不等式做不了呢？\n大佬：“那就来一把柯西，没有一把柯西搞不定的东西，如果有，就用两把！”\n当然，我们不是大佬，用一点蠢一点的办法，比如 ”偏微分“\n栗子 我们会求单变量函数的最值，能不能想办法把两个变量化成一个变量呢？\n不如我们先把 $b$ 当成常数，如果无论 $b$ 取何值，$a$ 原式永远在 $a$取同一个值时取到最小值，那么当原式取到最小值时，$a$ 一定等于这个值\n$b$ 也是同理\n这样我们只要把这两个值肝出来，问题就解决了嘛q(≧▽≦q)，至于方法，肯定是求导啊\n看不懂？我们来试一下:\n先把$b$当成常数，求其导数： $$ {\\partial \\over \\partial a}\\cdot (a^2+b^2-2ab)=2a-2b $$ 令其等于0: $$ \\Rightarrow a=b $$ 故$a=b$时原式取到最小值(需要讨论，此处省略)\n同样地，把$a$当成常数，求其导数： $$ {\\partial \\over \\partial b} (a^2+b^2-2ab)=2b-2a $$ 令其等于0： $$ \\Rightarrow a=b $$ 故$a=b$时原式取到最小值(需要讨论，此处省略)\n综上所述，$a=b$时原式取到最小值，为0\n注意到: $d\\rightarrow \\partial$ 了吗？$d$ 表示常微分，$\\partial$ 表示偏微分(微的都不是单变量函数了，当然得换一个)\n至于为什么上面单独有一个$\\partial$ ,那是因为右边那一坨太大了，怼上去不好看，所以单独拿出来，只留一个$\\partial$ 在上面\n本质 还是看不懂，那让我们看看偏微分的本质\n函数为什么一定是一个单变量的呢？为什么不能有两个自变量呢？\n当然可以，专业点，这个东西叫 二元函数\n既然是个函数，就可以化它的图像啦，不如看看$f(x,y)=x^2+y^2-2xy$的图像：\n这玩意变成一个立体图了！o((⊙﹏⊙))o. 联系一下一元函数取最值的情况——切线水平\n不难推测，二元函数取最值的情况是：切面水平 切面水平，怎么表示呢？\n显然，如果一个平面和一个曲面相切，过切点的任何一个面截这两个面所得的直线和曲线一定相切，反之亦然 (此处不严谨)\n所以我们只要找两条直线就好啦~\n所以我们只要找两个截面就行啦~\n截面当然是沿x轴一个沿y轴一个最方便啦~\n要问x轴上的截面截得的两条线的解析式当然令x等于一个固定值就行啦，y轴也一样~ 把x当成常数，导数就是这个曲面在沿x截面截得的曲线的切点的斜率随y变化的关系\n反之亦然\n我们只需要令这两个导数等于0，就确定了水平两条相交直线，并且这两条直线还与图像相切\n这样就确定了水平的切面\n进而就可以求出最大值\n以上部分看懂了最好，看不懂也没关系 （因为我写的也很绕(。_。)） 但只要记住：\n 把一个变量当常数，求导，令导数等于0，得到一条方程 把另一个变量当常数，求导，令导数等于0，得到另一条方程 \u0026hellip;\u0026hellip; 解这些方程，得到个个变量的值 把这些值带入原式，得到最值(此处还需讨论一下)  就可以使用了\n应用 有了这么强大的工具，我们干点什么好呢？\n不如来推导一下回归直线的最小二乘法的公式~\n有一堆点： $$ (x_1,y_1) , (x_2,y_2) , (x_3,y_3) \u0026hellip; (x_n,y_n) $$ 设回归直线为 $$ y=ax+b $$ 那么原来的点在直线上就是： $$ (x_1,ax_1+b) , (x_2,ax_2+b) , (x_3,ax_3+b) \u0026hellip; (x_n,ax_n+b)\n$$ 纵坐标的方差(类似？)的n倍就是： $$ \\begin{aligned} n\\sigma^2 \u0026amp;=\\sum_{i=1}^n (ax_i+b-y_i)^2=a^2\\sum_{i=1}^n x_i^2+2ab\\sum_{i=1}^nx_i-2a\\sum_{i=1}^nx_iy_i+nb^2+\\sum_{i=1}^ny_i^2-2b\\sum_{i=1}^ny_i\\\n\u0026amp;=a^2\\sum_{i=1}^n x_i^2+2nab\\overline x-2a\\sum_{i=1}^nx_iy_i+nb^2+\\sum_{i=1}^ny_i^2-2nb\\overline y \\end{aligned} $$ 当其取到最小值时，偏导数为0 对$a$求偏导： $$ {\\partial (n\\sigma^2)\\over \\partial a} = 2a\\sum_{i=1}^nx_i^2+2nb\\overline x-2\\sum_{i=1}^nx_iy_i $$ 令其等于零： $$ \\Rightarrow a\\sum_{i=1}^nx_i^2+nb\\overline x-\\sum_{i=1}^nx_iy_i=0·····(1) $$ 对$b$求偏导： $$ {\\partial (n\\sigma^2)\\over \\partial b} = 2na\\overline x+2nb-2n\\overline y\\\n$$ 令其等于0： $$ \\Rightarrow a\\overline x+b=\\overline y \\Rightarrow b=\\overline y-a\\overline x $$ 代入(1)式得： $$ a\\sum_{i=1}^nx_i^2+n\\overline x(\\overline y-ax\\overline )-\\sum_{i=1}^nx_iy_i=0\\\n\\Rightarrow a={\\sum_{i=1}^n x_iy_i-n\\overline x\\overline y\\over \\sum_{i=1}^n x_i^2-n\\overline x^2} $$ 推导完成，完结撒花 ✿✿ヽ(°▽°)ノ✿\n","date":"2020-07-22T00:00:00Z","image":"https://timgsa.baidu.com/timg?image\u0026quality=80\u0026size=b9999_10000\u0026sec=1595424976775\u0026di=d5e3760fd96da88eb8d7329fc1f81e2c\u0026imgtype=0\u0026src=http%3A%2F%2Fpic1.zhimg.com%2Fv2-e499e09400aefa4525e8dccdeb828d70_b.jpg","permalink":"https://gbwater.ga/p/%E5%81%8F%E5%BE%AE%E5%88%86/","title":"偏微分"},{"content":"重中之重   GUI版运行需要安装 .NET 4.7.2！！！若未安装，请运行：“NDP472-KB4054530-x86-x64-AllOS-ENU.exe”安装  5.0的setting.txt和其他版本的不兼容,不可互换！！！  由于使用了Qt，可能会导致兼容性问题\n  简介  实现在检测到u盘目录存在后将u盘目录中的文件复制到制定目录中 实现盘符和磁盘名称两种方法检测 用来复制指定u盘的文件 复制时保留源目录结构就是不仅把ppt搞出来还按原方式分文件夹 如有bitlocker锁，则等待解锁后复制就是u盘有密码也可以 经测试可正确运行于Windows10（2004），其他系统本蒟蒻就不知道了其实是懒得试 使用C++和Qt编写主程序 wpf+C# .net实现图形化 （本来用的是winform+VB .net，但嫌它丑） 使用命令行工具“ROBOCOPY”实现相关功能 本蒟蒻懒得敲 源代码也一并奉上，欢迎各位大神指导！如有雷同，纯属巧合 因使用此工具造成的损失本蒟蒻概不负责强行甩锅，逃。。。 \u0026hellip;\u0026hellip;  v 5.0.0更新内容  使用Qt+C++编写主程序 新增检测方式——磁盘名称 新增复制前等待选项，避让使用高峰期 更换bitlocker解锁检测方式，减小资源消耗  使用说明  编辑配置文件   编辑“setup.txt”完成配置 运行“start无提示.vbs”或“start有提示.vbs”运行程序，等待u盘插入（切不可直接运行copy.exe!） u盘插入后，程序自动复制文件 待u盘拔出后，检查复制出来的文件，若有需要，打开“log.txt”查看日志并进行下一步操作   使用GUI配置工具（推荐）   运行静默拷文件.exe，完成配置后，点击保存并启动按钮（高级选项 is useful，但不了解建议不要勾选） u盘插入后，程序自动复制文件 待u盘拔出后，检查复制出来的文件，若有需要，可以查看日志并进行下一步操作    “setup.txt”的填写及修改说明 请填写在提示字符的下一行（已留空，直接填在空行就好） 留空代表不使用该选项 删除时请留出空行，即各提示字符间必须留有一行空行，多了少了都不行 本蒟蒻已预先填写好一些内容，均可修改。但(不建议修改）的内容不建议修改及删除（大神请随意）    “start无提示.vbs”和“start有提示.vbs”无提示则复制完成后不会有任何反应，有提示则复制完成后会有一“您的资料已被盗！”弹窗弹出\n  setup.txt”配置选项 运行截图 下载 蜂鸟云盘\ngithub项目地址\n","date":"2020-07-22T00:00:00Z","image":"https://s1.ax1x.com/2020/07/22/UHSWuV.png","permalink":"https://gbwater.ga/p/%E9%9D%99%E9%BB%98%E6%8B%B7%E6%96%87%E4%BB%B6/","title":"静默拷文件"},{"content":"引子 数学家们在解决了导数这一迷之问题后，造就了迷之脑洞，想出了一些迷之问题\n比如这个:求函数$y=x^2$的图像和$x$轴以及直线$x=1$围成的面积\n有了导数的经验,数学家们一拍光秃秃的脑袋:\u0026ldquo;不如我们再玩一次$\\Delta$吧?\u0026rdquo;\n于是他们把$0\\rightarrow 1$分成了$n$份,画出了$n$个矩形,就像这样\n其中每个矩形的底都是$1\\over n$,高就是右端点横坐标的平方,即$x^2$,是第几个矩形,$x$就等于几倍$1\\over n$\n这样一来，矩形的面积之和:\n$$ \\begin{aligned} S \u0026amp;= {1\\over n}\\cdot \\left(1\\over n\\right)^2 + {1\\over n}\\cdot \\left(2\\over n\\right)^2+{1\\over n}\\cdot \\left(3\\over n\\right)^2+\u0026hellip;+{1\\over n}\\cdot \\left(n\\over n\\right)^2 \\\n\u0026amp;= {1\\over n}\\cdot \\left( \\left( 1\\over n\\right)^2+\\left( 2\\over n\\right)^2+\\left( 3\\over n\\right)^2+\u0026hellip;+\\left( n\\over n\\right)^2\\right) \\\n\u0026amp;= {1\\over n^3}\\cdot \\left(1^2+2^2+3^2+\u0026hellip;+n^2\\right)\\\n\u0026amp;= {1\\over n^3}\\cdot {n(n+1)(2n+1)\\over 6}\\\n\u0026amp;= {1\\over 3}+{1\\over 3n}+{1\\over 6n^2} \\end{aligned} $$ 然后，让$n\\rightarrow +\\infty$矩形的面积和就是所求面积，故： $$S={1\\over 3}$$ 数学家们老高兴了呢~\n一般化推广 在解决了上面的问题后，数学家们本着永无止境的心，又把1换成了$x_0$,让我们一起康康有什么变化：\n还是一样地把0~$x_0$分成$n$份，仿照上面画出$n$个矩形：\n$$ \\begin{aligned} S \u0026amp;= {x_0\\over n}\\cdot \\left(x_0\\over n\\right)^2 + {x_0\\over n}\\cdot \\left(2x_0\\over n\\right)^2+{x_0\\over n}\\cdot \\left(3x_0\\over n\\right)^2+\u0026hellip;+{x_0\\over n}\\cdot \\left(nx_0\\over n\\right)^2 \\\\\n\u0026amp;= {x_0\\over n}\\cdot \\left( \\left( x_0\\over n\\right)^2+\\left( 2x_0\\over n\\right)^2+\\left( 3x_0\\over n\\right)^2+\u0026hellip;+\\left( nx_0\\over n\\right)^2\\right) \\\\\n\u0026amp;= {x_0^3\\over n^3}\\cdot \\left(1^2+2^2+3^2+\u0026hellip;+n^2\\right)\\\\\n\u0026amp;= {x_0^3\\over n^3}\\cdot {n(n+1)(2n+1)\\over 6}\\\\\n\u0026amp;= {x_0^3\\over 3}+{x_0^3\\over 3n}+{x_0^3\\over 6n^2} \\end{aligned} $$ 接着，让$n\\rightarrow +\\infty$，那么: $$S={1\\over 3}x_0^3$$\n回顾上面的过程，本着偷懒的精神，数学家们开始简化算式：\n老是$1\\over n$的太烦，还要说明$n\\rightarrow +\\infty$,不如直接用导数里现成的$dx$代替$1\\over n$多省事ψ(｀∇´)ψ\n省略号太烦，还要列举前几项，$dx$又无限小，不能用求和符号，于是他们把求和符号拉长，创造了个新玩意：\n$$\\sum_{i=1}^n {1\\over n}\\cdot{i\\over n}^2\\rightarrow \\int_0^1 x^2dx$$ 看到这个，小问号的朋友又多了起来：woc这都是什么鬼东西(⊙_⊙)？\n$dx$就是$x$的一个微小变化量，我们以这个玩意作为矩形的底，画出$\\infty$个矩形\n那矩形的高怎么办呢？嘿嘿嘿，反正矩形的端点(反正底无限小，左右无所谓)的横坐标是$x$，我们直接拿$x^2$当高岂不是美滋滋（￣︶￣）↗\n于是乎，一个矩形的面积就是底乘高，即\n$$x^2 dx$$ 把0~1的所有矩形的面积加起来，就表示成： $$\\int_0^1x^2dx={1\\over 3}$$ 数学家们管这叫定积分 ,即有范围的积分，算出来是一个数，表示这个范围里函数图像围成的面积\n有 定 就一定有不定，即没有范围的积分，算出来是一个函数，表示从0开始函数图像围成的面积随$x$变化的关系:\n$$\\int x^2dx={1\\over 3}x^3$$\n积分的性质 不知道你发现没有 反正我是没有 ： $$\\int x^2dx={1\\over 3}x^3$$ $$({1\\over 3}x^3)'=x^2$$ 不定积分和导数一定有什么不可告人的秘密 ( •̀ ω •́ )✧ 假设我们有一个函数$f(x)%$： $$f'(x)={df(x)\\over dx }\\Rightarrow f'(x)dx=df(x)$$ 那么： $$\\int f'(x)dx=\\int df(x)=f(x)$$ 至于你问为什么： $$\\int df(x)=f(x)$$ 因为$df(x)=f(x+dx)-f(x)$,学过数列的小盆友一看就知道，这不就是一手裂项相消嘛~\n至此，我们发现了，求导和不定积分互为 逆运算 ！！！\n这样一来爽啦，什么积分不会搞，找找什么东西求导等于它就成啦！这样，数学家们搞出了一堆积分公式： $$\\int kdx=kx+C$$ $$\\int x^n={1\\over n+1}x^{n+1}+C$$ $$\\int {1\\over x}=\\ln x+C$$ $$\\int \\sin x dx=-\\cos x +C$$ $$\\int \\cos x dx=\\sin x +C$$ $$\u0026hellip;$$ 咦，这一堆$C$是干什么吃的？ 在积分式中： $$\\int f(x)dx=F(x)+C$$ 我们称$F(x)$为$f(x)$的一个原函数，就是$f(x)$求导之前原来的那个函数\n一个函数的原函数有无数个，因为求导后函数的常数部分直接就莫得了，所以积分时要把它加回去\n不信？看好喽： $$2=(2x)'=(2x+1)'=(2x+2)'=\u0026hellip;$$ 这真是要多少有多少 `(\u0026gt;﹏\u0026lt;)′\u0026gt;)\n秉承着偷懒至上的伟大精神，数学家们把这一堆常数合并成一个$C$，称其为“积分常数”\n真可谓 “大道至简，务实高效” 啊 没错，这就是我们前班主任的格言\n此外，积分和导数一样，有如下性质： $$\\int [f(x)+g(x)]=\\int f(x)+\\int g(x)$$ $$\\int [af(x)]=a\\int f(x)$$ 毕竟互为逆运算嘛，都是一家人¯\\ (°_o)/¯\n积分的运算 搞了这么久，你一定很想知道定积分怎么算吧？\n来，搬张板凳，继续吃瓜 ——牛顿——莱布尼茨公式 “\n 如果函数$f(x)$在区间$[a,b]$上连续，并且存在原函数$F(x)$ ,\n则： $$\\int_a^bf(x)dx=F(b)-F(a)=F(x)|_a^b$$\n 咦为什么没加$C$？因为$F(a)$和$F(b)$都加了$C$，一减就莫得了(｡･∀･)ﾉﾞ\n至于你问$F(x)|_a^b$是个什么意思，那就是$F(b)-F(a)$，目的就是少写几个字 (＃°Д°)\n证明嘛。。。围观大佬就好，切记，保护好头发ヾ(•ω•`)o\n看到这里，你以为你就会算积分了吗？no no no，比如这个：(大佬请绕路) $$\\int {1\\over x+1}dx = ?$$ 这就需要 换元积分法 了\n令$t=x+1$,则： $$\\int {1\\over x+1}dx=\\int {1\\over t}dx$$ 又有： $$t'=(x+1)'=x'\\Rightarrow dt=dx$$ $$原式=\\int {1\\over t}dt=\\ln t +C=\\ln(x+1)+C$$ 是不是很秀？\n尽管还有一些东西暂时积不出来，就先到这儿吧 因为我还不会，到时候再补，咬我呀~\n积分的应用 有了积分，我们就可以为所欲为地算一些奇奇怪怪的东西了\n比如算球的体积\n众所周知，球是由一个圆旋转得来的，我们取出那个圆，其半径为$r$，放到坐标系里，其方程就是： $$x^2+y^2=r^2$$ 因为一个半圆沿直径旋转就可以搞出一个球了，这里偷个懒，把它变成半圆： $$y=\\sqrt{r^2-x^2}$$ 秉承着偷懒的伟大精神，${1\\over 4}$圆沿半径旋转一圈是半球，算出这玩意的体积再乘个2就行了\n还是一样在里面画个长为$dx$矩形：\n它的高就是$\\sqrt{r^2-x^2}$\n这个小矩形沿$x$轴旋转一圈就是一个圆柱,这个圆柱的底面半径就是这个矩形的高，高就是这个矩形的底边长\n其体积为： $$\\pi\\cdot(\\sqrt{r^2-x^2})^2dx=\\pi r^2dx-\\pi x^2dx$$ 那把0~1这无数个小圆柱的体积加起来不就是这个半球的体积了？故： $$ \\begin{aligned} V \u0026amp;= \\int _0^r (\\pi r^2-\\pi x^2)dx\\\n\u0026amp;=(\\pi r^2 x-{\\pi \\over 3}x^3)|_0^r\\\n\u0026amp;={2\\over 3}\\pi r^3 \\end{aligned} $$ 那么球的体积就是这个半球体积的两倍： $$V_球={4\\over 3}\\pi r^3$$ 妙啊(*￣3￣)╭\n不仅如此，还可以算其他奇奇怪怪的东西，比如球的表面积、$y=x^2$沿$y$轴转一圈的体积等等\u0026hellip;\n总之，干旋转体这活特别在行\n完结撒花 ✿✿ヽ(°▽°)ノ✿\n","date":"2020-07-21T00:00:00Z","image":"https://ss1.bdstatic.com/70cFuXSh_Q1YnxGkpoWK1HF6hhy/it/u=1362029340,873040901\u0026fm=26\u0026gp=0.jpg","permalink":"https://gbwater.ga/p/%E7%A7%AF%E5%88%86/","title":"积分"},{"content":"引子 数学的很多分支都是由物理发展来的，微积分也不例外。\n据说导数一开始就是在求加速都时搞出来的。\n什么？你不知道什么是速度？不如先去学习一下：传送门\n具体是怎么搞出来的没人知道 (因为知道的人都挂了) ，但这并不妨碍我们模拟一下当时的情况：\n在一个月黑风高的夜晚，牛顿思索着对于位移满足关系式：$s=t^2$的运动在$t=1$的速度 牛顿：我怎么不知道？？？\n众所周知，$x-t$图像上某点切线的斜率即为该时刻的速度（什么？你不知道？刚不是叫你去学习了吗？） 令$s\\rightarrow y$ , $t\\rightarrow x$ , 作出它的图像和$x=1$时的切线：\n看到了啥？只有一个交点有木有！！！这不就意味着联立后的方程只有一个根，那就用判别式就完了呗？\n是时候干点啥了。\n设切线方程为： $y=kx+b$ , 于是\n$$ \\begin{cases} y \u0026amp; = x^2 \\\\\ny \u0026amp; = kx+b \\\n\\end{cases} $$ 又有$x=1,y=x^2=1$ $$ \\Rightarrow \\begin{cases} \u0026amp;k+b=1 \\\\\n\u0026amp;x^2-kx-b=0 \\\n\\end{cases} $$ 二次方程有木有！于是 $$\\Delta=k^2-4(k-1)=0 \\Rightarrow k=2$$ 由此可以得出，$t=1$时，$v=2$\n一般化推广 我们知道函数$y=x^2$在$x=1$的切线斜率是2,能不能让结论更加一般化呢?比如求其在$x=x_0$时的切线斜率?\n仿照上例:\n设切线方程为： $y=kx+b$ $$ \\begin{cases} y \u0026amp; = x_0^2 \\\\\ny \u0026amp; = kx_0+b \\end{cases} $$ 咦？求不出来了？？？！ Σ(っ °Д °;)っ\n有没有别的方法呢? 显然是有的,不然我就不会写这玩意了\u0026hellip;\u0026hellip;\n回顾刚才的过程，会发现切线的定义有问题。如图，这玩意也只有一个交点，但这明显不是我们想要的切线\n是时候重新定义一下切线了\n学过初中数学的都知道，两点确定一条直线，不如在函数上取两个点，不断缩小它们的距离，两点重合时，不就是切线了嘛！\n妙哉！说干就干：\n显然，已知两点$A(x_1,y_1),B(x_2,y_2)$,过这两点直线的斜率$k_{AB}={y_2-y_1 \\over x_2-x_1}$,即： $$k={\\Delta y \\over \\Delta x}$$ 设点$A,B$在$y=x^2$上,不妨设$A(x_0,x_0^2),B(x_0+ \\Delta x , (x_0+ \\Delta x)^2)$\n当$A,B$重合,即$\\Delta x$极小时,$k$即为该点的斜率\n看不懂?上动图!\n于是:\n$$k={\\Delta y \\over \\Delta x}={(x_0+\\Delta x)^2-x_0^2 \\over \\Delta x}={2x_0\\Delta x+\\Delta x^2\\over \\Delta x}=2x_0+\\Delta x$$ $\\Rightarrow$当$\\Delta x\\rightarrow 0$时,$k=2x_0$\n这是不是爽多了ヾ(•ω•`)o\n看到这里，小问号你是不是有很多朋友：导数是啥？跟这有关系吗？\n是时候走一手定义了：\n还在因为导数是什么而迷惑？导数就是函数的图像在某一点的切线斜率，即上文的k\n此外，数学家们觉得$\\Delta$太难用，不仅难写 ~~（并不觉得）~~，还要不断给自己心理暗示这玩意无限趋近于0\n于是：\n$$\\Delta x\\rightarrow dx , \\Delta y \\rightarrow dy $$\n$d$啥 就是啥的微小变化量\n还有，每一个$x$都对应着一个$k$，这明摆着$k$是$x$的函数嘛！又考虑到导数没有符号表示，$k$来$k$去的十分不爽，数学家们大笔一挥，在函数的右上角加了一撇，表示这个函数的导函数，即导数关于$x$的函数,如：\n$y'\\rightarrow y$的导函数 $f'(x)\\rightarrow f(x)$的导函数 甚至还可以这么玩：$(sin x)'$ 和 $[f(x)g(x)]'$ 以及 $(f(g(x)))'$\n这样一来爽多了：\n$$y'={dy\\over dx}=2x$$ 换成$f(x)$：\n$$f'(x)={df(x)\\over dx}=2x$$\n导函数的性质 复合函数的导函数 $(f(g(x))'$这二货咋求？\n常识告诉我们，最先出现的问题一定是用定义解决的：\n$$(f(g(x))'={df(g(x))\\over dx}$$ 然后呢？好问题\u0026hellip;看我来一手骚操作: $${df(g(x))\\over dx}={df(g(x))\\over dg(x)}·{dg(x)\\over dx}=f'(x)g'(x)$$ 这玩意可以约分，想不到吧，嘿嘿嘿（〃｀ 3′〃）\n由此得出:两函数复合，其导函数为两函数的导函数之积\n函数之积的导函数 有了上面的经验，还是一手骚操作: $$[f(x)g(x)]'={[f(x)+df(x)][g(x)+dg(x)]-f(x)g(x)\\over dx}=f(x){dg(x) \\over dx}+g(x){df(x) \\over dx}$$ $$=f(x)g'(x)+f'(x)g(x)$$ 咦？$df(x)dg(x)\\over dx$哪去了？被我吃了吗？其实是它太小了。只要乘了个带$d$的，就不配拥有人权~ ╰(￣ω￣ｏ)\n函数之商的导函数 众所周知，大题的最后一问总是会用到前两问的结论，这个当然也不例外\n稍微变个型： $$[{f(x)\\over g(x)}]'=[f(x){1\\over g(x)}]'$$ 那不就是两函数之积的导函数嘛 ~(￣▽￣)~*\n至于这个$1\\over g(x)$，不就是一个$u(x)={1\\over x}$ 和 $g(x)$ 复合成 $u(g(x))$ 了嘛\u0026hellip; (￣﹃￣)\n反手就是一顿操作：\n$$原式={f'(x)\\over g(x)}-{f(x)g'(x)\\over [g(x)]^2}={f'(x)g(x)-f(x)g'(x)\\over [g(x)]^2}$$\n其他性质 $$[f(x)+g(x)]'=f'(x)+g'(x)$$ $$[af(x)]'=af'(x)$$ 至于证明嘛，送你一首《西江月·证明》\n一些常见函数的导函数 常函数 $C'=0$ 这有什么难的，横着一条直线的斜率不是0还能是啥？\n一次函数 $(kx)'=k$ 一次函数嘛，它的切线就是它自己，导数即斜率，斜率即$k$\n幂函数: $f(x)=x^n\\Rightarrow f'(x)=nx^{n-1}$ 在这里我们直接上通用方法,需要使用二项式定理:\n$$f'(x)={df(x) \\over dx}={(x+dx)^n-x^n \\over dx}={\\tbinom{1}{n}x^{n-1}dx+\\tbinom{2}{n}x^{n-2}dx^2+\u0026hellip;+dx^n \\over dx}$$ $$=\\tbinom{1}{n}x^{n-1}+\\tbinom{2}{n}x^{n-2}dx+\u0026hellip;+dx^{n-1}=nx^{n-1}$$\n三角函数:$(sin x)'=cos x$ , $(cos x)'=-sin x$ 这个需要用到一点和差化积的姿势 $$(sin x)'={sin(x+dx)-sin x \\over dx}={2cos(x+{dx\\over 2}) sin {dx \\over 2}\\over dx}$$ 又有: $$\\lim\\limits_{x\\rightarrow 0}\\sin x=x$$ $$\\Rightarrow (sin x)'=cos x$$ $cos x$同理，其实是我懒得打了(￣y▽,￣)╭\n指数函数: $(a^x)'=a^xlna$ 据说数学家们经大量计算发现，这玩意的导函数就是一个常数乘以它自己，而且这个常数还会变！\n于是他们怒了，设了一个常数$e$使得$(e^x)'=e^x$ 没错这就是$e$的由来 ¯\\_ (ツ)_/¯\n于是： $$e^{ln x}=x \\Rightarrow (e^{ln x})'=1$$ 由复合函数求导的姿势：\n$$ (e^{ln x})'=e^{ln x}(ln x)'$$ $$\\Rightarrow (xln x)'=1 \\Rightarrow (ln x)'={1\\over x}$$ 于是我们就可以把指数给他拉下来了：\n$$ln(a^x)=xln(a) \\Rightarrow [ln(a^x)]'=[xln(a)]'=lna$$ 又有(复合函数求导)： $$[ln(a^x)]'={1\\over a^x}·(a^x)'$$ $$\\Rightarrow (a^x)'=a^xlna$$\n对数函数:$(log_a{x})'={1\\over xlna}$ 这里来一手换底公式就变成了函数之商求导，over： $$(log_a{x})'=({lnx\\over lna})'={1\\over xlna}$$\n导数的应用 看了这么久，小问号的朋友一定越来越多了，这有啥用呢？\n其实，导数最大的用处就是求函数的单调性和最值，最大值和最小值都能搞定\n显然，增函数的导数大于0，减函数的导数小于0，导数的绝对值越大，函数值变化得就越快\n为啥？导数是斜率啊~ 换句话说，函数单调递增时其导数大于0，单调递减时导数小于0\n那导数等于0时呢？那就是被夹在增区间和减区间的交界处了呗，不是最大值就是最小值( ﹁ ﹁ ) ~→\n来，直观感受一下\n那么求函数增区间的问题就变成了解 导数\u0026gt;0 的不等式\n求函数最值就变成了解 导数=0 的方程\n岂不是美滋滋ヾ(≧▽≦*)o\n例：讨论函数$f(x)={1\\over 2}x^3-{3\\over 2}x$的单调性\n$$f'(x)={3\\over 2}x^2-{3\\over 2}={3\\over 2}(x+1)(x-1)$$ $$\\therefore x\\in (-\\infty ,-1)\\cup (1,+\\infty)时，f'(x)\u0026gt;0,x\\in (-1,1)时f'(x)\u0026lt;0$$ $$\\therefore f(x)在(-\\infty,-1)和(1,+\\infty)上单调递增，在(-1,1)上单调递减$$\n完结撒花 ✿✿ヽ(°▽°)ノ✿\n","date":"2020-07-18T00:00:00Z","image":"https://timgsa.baidu.com/timg?image\u0026quality=80\u0026size=b9999_10000\u0026sec=1595088441530\u0026di=ec0a63deebd73fdc0d2cad4d971afb56\u0026imgtype=0\u0026src=http%3A%2F%2Fd.hiphotos.baidu.com%2Fbaike%2Fpic%2Fitem%2Fe7cd7b899e510fb3cc0a63b2db33c895d1430c87.jpg","permalink":"https://gbwater.ga/p/%E5%AF%BC%E6%95%B0/","title":"导数"},{"content":" “我的学生都战死了，现在轮到我这个老师上去了！”\n1940年一名中央航空教练员驾驶飞机冲向32架日本轰炸机前留在日记本上的最后一句话\n “冲锋之势,有进无退,陷阵之志,有死无生”——三国•高顺\n“只解沙场为国死，何须马革裹尸还”——清•徐锡麟《出塞》\n“烈士不怕死，所死在忠贞。”——唐•柳宗元《韦道安》\n 伊卡洛斯（希腊文：Ίκαρος英文名称：Icarus）是希腊神话中代达罗斯的儿子，与代达罗斯使用蜡和羽毛造的翼逃离克里特岛时，他因飞得太高，双翼上的蜡遭太阳融化跌落水中丧生……\n欲望淹于所及之高\n便会窒息\n 十五年过去了。我们 有了自己的三代机和四代机，我们有了自己的大飞机，我们有了自己的航母。还记得十五年前，南海上空的英灵吗？中国最大的幸运，就是永远有层出不穷的英雄；中国最大的不幸，就是永远匮乏铭记英雄们的人。让我们永远记住:有一个编号，叫做81192；有一个英雄，叫做王伟。\n 1940年5月，枣宜会战。他亲自率领部队与敌寇决战。在部队被敌层层包围的不利态势下，他身先士卒、冲锋在前、力战不退，与敌寇拼死搏杀，最后身中7弹，壮烈殉国的张自忠将军\n “人一旦堕落，上帝就会以最快的速度收走你的天赋和力量” ――蒋方舟  ","date":"2020-06-27T00:00:00Z","permalink":"https://gbwater.ga/p/%E7%BD%91%E6%98%93%E4%BA%91%E8%AE%BA%E6%8D%AE/","title":"网易云论据"},{"content":"起因 今天碰巧看到一个迅雷的和谐版本，测试可用，十分激动\n使用方法  解压文件 这不是废话吗 打开这个文件夹  运行这个程序 这么显然还要我说？没错是来凑字数的w(ﾟДﾟ)w  可以复制下载链接，软件自动监视剪切板，也可以手动添加下载链接  运行截图 测试 我上官网找了个Windows10的镜像 不然不够大 ，测试可以跑满我家200M的带宽\n看着这飞一般的速度有木有很爽，233333\n特殊问题修复 如果运行出现这个错误 请打开这个文件夹 自选32位和64位的插件运行安装\n下载链接 百度网盘 提取码：kbsh\n解压密码：thunder 由于怕被百度和谐了，特此加密\n声明 照例走一遍流程\n此软件仅用于学习用途，请于下载后24小时内删除 资源来自\u0026quot;大力说科技\u0026ldquo;公众号，微信号：dalishuokeji\n","date":"2020-04-29T00:00:00Z","image":"https://timgsa.baidu.com/timg?image\u0026quality=80\u0026size=b9999_10000\u0026sec=1588181082437\u0026di=ad9d397990867afe3c836eb1bfcc751d\u0026imgtype=0\u0026src=http%3A%2F%2Fp2.ssl.cdn.btime.com%2Ft01a38f6b69934b7f3c.jpg%3Fsize%3D626x451","permalink":"https://gbwater.ga/p/%E8%BF%85%E9%9B%B7%E5%92%8C%E8%B0%90%E7%89%88/","title":"迅雷和谐版"},{"content":"简介 主席树是一种数据结构，用来解决区间第k小(大)问题。要问为什么叫主席树？因为这是一个叫黄嘉泰的dalao发明的 名字缩写跟我国某位主席一样，Orz\n时间复杂度是Onlogn，十分优秀 空间复杂度倒是有点大\n前置姿势 权值线段树  众所周知，权值线段树是一种线段树 话说这不是废话吗2333 它不同于一般线段树的是它的每一个结点的值代表这个区间中的数在序列中出现的总次数，正所谓“权值” 它可以被用来处理区间第k小(大)问题  查询原理 此处利用二分的思想： 现有区间[l,r],不妨设区间[l,m] ( m为区间中间位置 ) 内的数的个数为n: 显然:\n若 n \u0026lt; k ，第k小就是区间[m+1,r]的第 k - n 小 反之，则为区间[l,r]的第k小 于是可以写出伪代码\n1 2 3 4 5 6 7  int que(k,l,r)//询问区间[l,r]的第k小 { if(l==r) return l; int m=(l+r)/2; if(cnt(l,m)\u0026gt;=k) return que(k,l,m); return que(k-cnt(l,r),m+1,r); }   举个栗子 对于序列 1,3,2,2,0,1 建立的权值线段树如下 查询第3小：\n 访问区间[0,3],有6个数，\u0026gt; 3 访问左区间[0,1]查询第3小,有3个数,=3 访问右区间[1,1],查询第2小，返回结果-\u0026gt;1  建树 当然是递归建树啦ψ(｀∇´)ψ\n此处同普通线段树,只需统计区间个数即可\n此处使用暴力统计 其实是懒得打\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26  int ls[100],rs[100],cnt=0,v[100]; int l[100],r[100]; int num[100]; int n; void update(int p) { v[p]=v[ls[p]]+v[rs[p]]; } void build(int p,int l,int r) { l[p]=l;r[p]=r; if(l==r) { for(int i=0;i\u0026lt;n;i++) { if(num[i]\u0026gt;=l\u0026amp;\u0026amp;num[i]\u0026lt;=r) v[p]++; } return; } int m=l+r\u0026gt;\u0026gt;1; ls[p]=++cnt; rs[p]=++cnt; build(ls[p],l,m); build(rs[p],m+1,r); update(p); }   查询 1 2 3 4 5 6 7  int que(int p,int k) { if(l[p]==r[p]) return l; int m=l[p]+r[p]\u0026gt;\u0026gt;1; if(v[p]\u0026lt;k) return que(rs[p],k-v[p]); return que(ls[p],k); }   思想 权值线段树有一个缺点，只能查询整个区间的第k小，对于子区间就无能为力了\n那是不是对于所有子区间都能搞出一个权值线段树就好了呢？\n前缀和 这里就可以用前缀和的思想：\n若用相同范围（即相同的l，r）对任意子区间建树，所有的权值线段树结构相同，这意味着两棵树可以相减（即每一个等位节点相减）！\n于是我们可以依次对[0,0],[0,1],[0,2]\u0026hellip;[0,n]建树，如需得到[l,r]的树，只需将[0,r]和[0,l-1]两棵线段树相减即可！\n查询可以机智地使用宏定义\n1 2  #define lv (value[ls[r]]-value[ls[l]])//相减后得到的线段树左儿子的值 #define rv (value[rs[r]]-value[rs[l]])//相减后得到的线段树右儿子的值   空间优化 然而这里有一个问题，每一个区间建立线段树，空间复杂度太大，无法接受\n怎么优化呢？\n实际上，下一棵线段树就相当于上一棵线段树进行单点更新，即[0,n]相对于[0,n-1]只是更新了[num[n],num[n]]的值而已。\n由于主席树不是完全二叉树，需要开数组保存左右儿子的编号，这里利用一下：如果更新左儿子，就把右儿子编号赋为上一棵树该节点右儿子的编号，反之也一样。这样每次建树只需新开一条链就行了 有没有感觉特别机智\n更新\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19  void updata(int last/*上一棵线段树等位结点编号*/, int p, int v)//建立下一棵线段树,相当于线段树的单点更新,只需保存一条链而已 { ln[p] = ln[last]; rn[p] = rn[last];//这棵线段树和上一棵一样,直接赋值 \tvalue[p] = value[last] + 1;//明显v包含在区间里,直接加一即可 \tif (ln[p] == rn[p]) return;//叶节点,不用继续更新,直接返回即可 \tif (v \u0026lt;= (ln[p] + rn[p] \u0026gt;\u0026gt; 1))//包含在左儿子的区间中 \t{ rs[p] = rs[last];//右子树(即右儿子)和上一棵线段树的一样 \tls[p] = ++cnt;//累计节点编号 \t//本来更新节点的值是写在这里的,但这样根节点就更新不了了,于是写到了前面 \tupdata(ls[last], ls[p], v);//建立左子树 \t} else//反之亦然同理 \t{ ls[p] = ls[last]; rs[p] = ++cnt; updata(rs[last], rs[p], v); } }   循环建树\n1 2 3 4 5 6 7 8 9 10  void build()//建立主席树 { root[0] = cnt;//0号根节点为空树,便于相减 \tbud(0, n2 - 1, cnt);//先建一发空树 \tfor (int i = 0; i \u0026lt; n; i++)//[0,n)和(0,n]皆可,只不过是root[i-1]和root[i+1]的区别 \t{ root[i + 1] = ++cnt;//累计根节点 \tupdata(root[i], root[i + 1], num[i]);//更新这棵线段树 \t} }   离散化 然而还有一个问题，权值线段树的空间复杂度是与数据范围相关的，所以此处需要离散化。所谓离散化就是把一堆范围很大的数映射到一段很小的区间里\n例如对于序列：12 , 76 , 123 , 67 , 1 , 20\n排序后：1 , 12 , 20 , 67 , 76 , 123\n令：1-\u0026gt;1 , 12-\u0026gt;2 , 20-\u0026gt;3 , 67-\u0026gt;4 , 76-\u0026gt;5 , 123-\u0026gt;6\n原序列就变成了：2 , 5 , 6 , 4 , 1 , 3\n至于怎么搞映射？这不是map最擅长的吗（￣︶￣）↗　1 2 3 4 5 6 7 8 9 10 11 12 13 14  map \u0026lt;int, int\u0026gt; po/*由原值映射到离散化后的值*/, re/*由离散化后的值映射到原值*/; sort(tmp, tmp + n);//先来一发排序 //巨坑!!tmp+n是排序区间末区间端点的下一个值的地址!!! //我也不知道STL为什么要这样反正我就这样爆了两个点 n2 = unique(tmp, tmp + n) - tmp;//去重也一样!!!(STL的东西都是这个尿性) for (int i = 0; i \u0026lt; n2; i++)//记录离散化后的数值 { po[tmp[i]] = i; re[i] = tmp[i]; } for (int i = 0; i \u0026lt; n; i++)//将原值变为离散化后的值 { num[i] = po[num[i]]; }   输出答案时也别忘了搞回去\n1  cout \u0026lt;\u0026lt; re[ans] \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;;//输出答案,一定要离散化的数值搞回来!!!小心爆零!!!   完整代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112  /* 主席树 20191210 皮:震惊,cin和cout,竟然没有没有TLE???数据竟然没有爆int???!!! */ #include\u0026lt;iostream\u0026gt;#include\u0026lt;map\u0026gt;#include\u0026lt;algorithm\u0026gt;#include\u0026lt;cstdio\u0026gt;using namespace std; int ls[20000000]/*保存节点左儿子*/, rs[20000000]/*保存节点右儿子*/, root[200010]/*保存第一个元素到第n个数对应权值线段树的根节点*/, value[20000000]/*保存权值线段树节点的值*/, ln[20000000]/*保存节点区间左端点*/, rn[20000000]/*保存节点区间右端点*/; int cnt/*累计节点编号*/, n/*数的个数*/; int n2/*排序去重后数的个数(离散化巨坑)*/; int num[200010]/*保存序列*/, tmp[200010]/*便于离散化*/; void bud(int l, int r, int p)//建立空树(便于线段树相减),同普通线段树,只是没有保存节点权值而已 { ln[p] = l; rn[p] = r;//显然 \tif (l != r)//巨坑,否则死循环!!! \t{ ls[p] = ++cnt;//累计子节点 \tbud(l, (l + r \u0026gt;\u0026gt; 1), cnt);//递归建立左子树 \trs[p] = ++cnt;//累计子节点 \tbud((l + r \u0026gt;\u0026gt; 1) + 1, r, cnt);//递归建立右子树 \t} } void updata(int last/*上一棵线段树等位结点编号*/, int p, int v)//建立下一棵线段树,相当于线段树的单点更新,只需保存一条链而已 { ln[p] = ln[last]; rn[p] = rn[last];//这棵线段树和上一棵一样,直接赋值 \tvalue[p] = value[last] + 1;//明显v包含在区间里,直接加一即可 \tif (ln[p] == rn[p]) return;//叶节点,不用继续更新,直接返回即可 \tif (v \u0026lt;= (ln[p] + rn[p] \u0026gt;\u0026gt; 1))//包含在左儿子的区间中 \t{ rs[p] = rs[last];//右子树(即右儿子)和上一棵线段树的一样 \tls[p] = ++cnt;//累计节点编号 \t//本来更新节点的值是写在这里的,但这样根节点就更新不了了,于是写到了前面 \tupdata(ls[last], ls[p], v);//建立左子树 \t} else//反之亦然同理 \t{ ls[p] = ls[last]; rs[p] = ++cnt; updata(rs[last], rs[p], v); } } void build()//建立主席树 { root[0] = cnt;//0号根节点为空树,便于相减 \tbud(0, n2 - 1, cnt);//先建一发空树 \tfor (int i = 0; i \u0026lt; n; i++)//[0,n)和(0,n]皆可,只不过是root[i-1]和root[i+1]的区别 \t{ root[i + 1] = ++cnt;//累计根节点 \tupdata(root[i], root[i + 1], num[i]);//更新这棵线段树 \t} } //这类宏定义一定要加括号，否则死的很惨！！！！！！ //我才不会告诉你我就是因为这个第一次交爆零了... //还有,宏定义这种东西作用范围是当前文件...写在哪里都一样... #define lv (value[ls[r]]-value[ls[l]])//相减后得到的线段树左儿子的值 #define rv (value[rs[r]]-value[rs[l]])//相减后得到的线段树右儿子的值 int ans;//落谷猥琐巨坑,直接返回会MLE!!!被迫改void并使用全局变量保存答案 void query(int k, int l, int r)//这里的l和r指的不是数列的区间,而是l棵线段树和第r棵线段树的根节点 { //直接写成(其实就是)权值的查询就好 \tif (ln[l] == rn[l])//叶节点,直接记录答案 \t{ ans = ln[l]; return; } if (k \u0026lt;= lv)//左儿子包含的数的个数大于等于待查询的k \tquery(k, ls[l], ls[r]);//向左儿子查询第k小即可 \telse//左儿子包含的数的个数小于待查询的k \tquery(k - lv, rs[l], rs[r]);//整段区间的第k小即为右区间的第(k-左区间包含数的个数)小 } map \u0026lt;int, int\u0026gt; po/*由原值映射到离散化后的值*/, re/*由离散化后的值映射到原值*/; int main() { cin \u0026gt;\u0026gt; n;//输入,显然 \tint m; cin \u0026gt;\u0026gt; m; for (int i = 0; i \u0026lt; n; i++)//输入并保存副本用于离散化 \t{ cin \u0026gt;\u0026gt; num[i]; tmp[i] = num[i]; } //---------------------------------------离散化-------------------------------------------- \tsort(tmp, tmp + n);//先来一发排序 \t//巨坑!!tmp+n是排序区间末区间端点的下一个值的地址!!! \t//我也不知道STL为什么要这样反正我就这样爆了两个点 \tn2 = unique(tmp, tmp + n) - tmp;//去重也一样!!!(STL的东西都是这个尿性) \tfor (int i = 0; i \u0026lt; n2; i++)//记录离散化后的数值 \t{ po[tmp[i]] = i; re[i] = tmp[i]; } for (int i = 0; i \u0026lt; n; i++)//将原值变为离散化后的值 \t{ num[i] = po[num[i]]; } //----------------------------------------------------------------------------------------- \tbuild();//建立主席树 \tint l, r, k; while (m--) { cin \u0026gt;\u0026gt; l \u0026gt;\u0026gt; r \u0026gt;\u0026gt; k; l--; query(k, root[l], root[r]);//一定要传递根节点的编号!!!!!! \tcout \u0026lt;\u0026lt; re[ans] \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;;//输出答案,一定要离散化的数值搞回来!!!小心爆零!!! \t} return 0; }   ","date":"2020-04-28T00:00:00Z","image":"https://timgsa.baidu.com/timg?image\u0026quality=80\u0026size=b9999_10000\u0026sec=1587878842959\u0026di=d865670296e9efbf79ee1fe7fa5166cb\u0026imgtype=0\u0026src=http%3A%2F%2Fmedia.hihocoder.com%2Fproblem_images%2F20141108%2F14154249931829.png","permalink":"https://gbwater.ga/p/%E4%B8%BB%E5%B8%AD%E6%A0%91/","title":"主席树"},{"content":"简介 对于RMQ问题，暴力计算时间复杂度踏大了，所以要预处理\n预处理全部子区间空间复杂度踏大了，预处理的时间复杂度踏大了，还贼难修改\n如果能预处理一部分子区间，正好对上查询区间最好，对不上也能用预处理过的区间“拼凑”出查询区间，时间空间复杂度还小就完美了\n区间怎么选呢？当然是二分啦 多么优秀的想法\n线段树是一种数据结构，用来解决RMQ(区间最值)问题 当然拓展一下也可以有别的用法\n顾名思义，线段树是一棵二叉树 ，所谓线段，特别之处是线段树上的每个结点代表一个区间\n其查询和修改的时间复杂度为Olog(n)\n工作原理 对于一棵线段树来说，每个节点有两个子节点，每个节点的区间长度都是其父节点的一半，并提前预处理好了每个节点代表区间的待查询数据。这样在查询和修改时，就可以分为三类：\n 在区间的左半边 在区间的右半边 在左半边和右半边都有分布  这样在查询和修改时就可以按这三种情况进行操作，直到找到的区间\n 在\n就像在欧亚大陆上找一个地方，可以分为三种情况： 全部在欧洲，如英国 全部在亚洲，如中国 横跨欧亚大陆，如俄罗斯  这样在查询的时候，每次将查询的区间缩小一半，复杂度就达到了$log(n)$级别\n基础 查询 比如有一段序列：1 , 3 , 5 , 2 ，2\n建立的线段树(每个结点保存其区间的最大值)如下 暂且先不管它是怎么建立的\n观察这棵树，可以发现有这两个特点  叶结点 区间长度为1，代表这段序列中的一个个数字 其它结点 的的区间是其两个子节点区间的并集  查询方法  待查询区间位于左子节点，向左子节点递归查询，并返回结果 待查询区间位于右子节点，向右子节点递归查询，并返回结果 待查询区间分布于两个子节点，拆分区间使其包含于被两个子节点的区间，向两个子节点递归查询，比较，并返回结果  模拟一下查询的过程(查询区间 [2,4] 的最大值)  访问根节点，其区间为[0,4]，不是待查询区间，且待查询区间分布于其两个子节点 将待查询区间分为[2,2]和[3,4]向左子节点查询[2,2] 左子节点:其区间为[0,2]，不是待查询区间，待查询区间位于其右子节点 访问左子节点的右子节点，其区间为[2,2]，是待查询区间，返回结果：5 左子节点返回结果：5 向右子节点查询区间[3,4] 右子节点:其区间为[3,4]，是待查询区间，返回结果：2 比较两子节点返回值：5\u0026gt;2，查返回询结果：5  可以由此写出查询代码(最大值) 1 2 3 4 5 6 7 8 9 10  double finda(node *p, int l, int r) { int mid = (p-\u0026gt;r - p-\u0026gt;l) / 2; if (p-\u0026gt;l \u0026lt;= l \u0026amp;\u0026amp; p-\u0026gt;r \u0026gt;= r)//若区间被完全包含 \t{ if (p-\u0026gt;l + mid \u0026gt;= r) return finda(p-\u0026gt;left, l, r);//待查询区间位于其左子树.查询左子树 \tif (p-\u0026gt;l + mid \u0026lt; l) return finda(p-\u0026gt;right, l, r);//待查询区间位于其右子树,查询右子树 \treturn max(finda(p-\u0026gt;left, l, p-\u0026gt;l + mid), finda(p-\u0026gt;right, p-\u0026gt;l + mid + 1, r));//从中间切开,递归分别查询,返回最大值 \t} }   修改 单点修改 顾名思义，单点修改就是修改序列中的一个数\n还是这段序列和这棵线段树\n修改方法  找到待修改的叶结点 修改叶结点的值 更新其父节点的值  模拟一下单点修改的过程(将[1,1]这个数修改为9)  访问根节点，待修改节点位于其左子树 访问其左子节点，待修改节点位于其左子树 访问其左子节点，待修改节点是其右子节点 访问其右子节点，修改其值为9 返回其父节点，9\u0026gt;1，更新其值为9 返回其父节点，9\u0026gt;5，更新其值为9 返回其父节点，9\u0026gt;2，更新其值为9 到达根节点，修改结束  由此可以写出单点修改代码(最大值) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21  void change(node *p, int s, int v) { if(p-\u0026gt;l==p-\u0026gt;r==s) //找到待修改节点，修改  { p-\u0026gt;v=v; return; } int mid = (p-\u0026gt;r - p-\u0026gt;l) / 2; if (p-\u0026gt;l + mid \u0026gt;= s) { change(p-\u0026gt;left, s, v);//待查询区间位于其左子树.查询左子树  update(p);//更新该节点的值  return; } if (p-\u0026gt;l + mid \u0026lt; s) { change(p-\u0026gt;right, s, v);//待查询区间位于其右子树,查询右子树  update(p);//更新该节点的值  return; } }   区间修改 顾名思义，区间修改就是对指定的区间进行 + - * / 操作\n思路 一种想法是对区间中的每个数进行单点修改操作，然而这样做复杂度是Onlog(n)，太大，不可取\n上文提到线段树的区间修改可以做到Olog(n)的复杂度，这是怎么实现的呢？\n回顾简单思路的问题：不难发现，这样把线段树全部相关节点都修改了，然而有些节点可能不会被使用到\n举个栗子：如果按照这种思路将[0,4]全部+1,而后查询区间却没有包含[0,2]，那么[0,2]这个子树就等于白修改了\n不难想到解决方法：标记相关子树的根结点，表示这棵子树上的全部结点的值都被修改，使用时再把标记传递给子节点就好了\n修改方法  待查询区间就是此区间，打上标记，返回 待查询区间位于左子节点，向左子节点递归修改，更新 待查询区间位于右子节点，向右子节点递归修改，更新 待查询区间分布于两个子节点，拆分区间使其包含于被两个子节点的区间，向两个子节点递归修改，更新  后续查询方法  待查询区间位于左子节点，把标记传递给左子节点并向其递归查询，并返回结果 待查询区间位于右子节点，把标记传递给右子节点并向其递归查询，并返回结果 待查询区间分布于两个子节点，拆分区间使其包含于被两个子节点的区间，把标记传递给两个子节点并向其递归查询，比较，并返回结果  模拟一下修改的过程(将[0,3]区间的数全部+1)  访问根节点，不是待修改区间，拆分待修改区间为[0,2]和[3,3] 向左子树查询，是待修改区间，修改标记为1，更新值为6，返回  向右子树查询，不是待修改区间，待修改区间位于其左子树 向其左子树查询，是待修改区间，且是叶结点，直接修改，返回  3\u0026gt;2，更新值为3，返回  6\u0026gt;3，更新值为6，结束   再模拟一下查询的过程(查询[2,3]的最大值)  访问根节点，不是待查询区间，拆分其为[2,2]和[3,3] 向左子树查询，不是待查询区间，进一步查询前把标记传递给两个子节点并更新它们的值  待查询区间位于其右子树，向右子树查询 待查询区间是此区间，返回结果：6 返回结果：6 向右子树查询(此处省略查询步骤)，返回结果：3 6\u0026gt;3，返回查询结果：6  由此可以写出修改代码 更新\n1 2 3 4  void updata(node *p) { p-\u0026gt;max = max(p-\u0026gt;left-\u0026gt;max, p-\u0026gt;right-\u0026gt;max);//更新最大值 }   传递标记\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23  void down(node* p) { if (p-\u0026gt;lazy_add == 0) return;//若没有标记,传递啥? \tif (p-\u0026gt;left-\u0026gt;l == p-\u0026gt;left-\u0026gt;r)//若为叶子结点,无需修改其标记(根本就没标记...) \t{ p-\u0026gt;left-\u0026gt;max += p-\u0026gt;lazy_add; } else//否则,先修改标记,再修改值 \t{ p-\u0026gt;left-\u0026gt;lazy_add += p-\u0026gt;lazy_add; p-\u0026gt;left-\u0026gt;max += p-\u0026gt;lazy_add; } if (p-\u0026gt;right-\u0026gt;l == p-\u0026gt;right-\u0026gt;r)//同上(本来就是复制下来的...) \t{ p-\u0026gt;right-\u0026gt;max += p-\u0026gt;lazy_add; } else { p-\u0026gt;right-\u0026gt;lazy_add += p-\u0026gt;lazy_add; p-\u0026gt;right-\u0026gt;max +=p-\u0026gt;lazy_add; } p-\u0026gt;lazy_add = 0;//删除加法标记 }   区间加法\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25  void _add(node *p, int l, int r, double k) { if (p-\u0026gt;l == l \u0026amp;\u0026amp; p-\u0026gt;r == r)//若区间完全重合 \t{ if (p-\u0026gt;l != p-\u0026gt;r) p-\u0026gt;lazy_add += k;//若不是叶子结点,更新加法标记 \tp-\u0026gt;min += k;//更新区间最小值 \tp-\u0026gt;max += k;//更新区间最大值 \tp-\u0026gt;sum += k * (p-\u0026gt;r - p-\u0026gt;l + 1);//更新区间和 \treturn; } int mid = (p-\u0026gt;r - p-\u0026gt;l) / 2; if (p-\u0026gt;l \u0026lt;= l \u0026amp;\u0026amp; p-\u0026gt;r \u0026gt;= r)//若区间被包含 \t{ down(p);//使用子树前先传递标记 \tif (p-\u0026gt;l + mid \u0026gt;= r) _add(p-\u0026gt;left, l, r, k);//若区间完全位于其左子树,向左子树查找区间l~r并执行加法 \telse if (p-\u0026gt;l + mid \u0026lt; l) _add(p-\u0026gt;right, l, r, k);//若区间完全位于其右子树,向右子树查找区间l~r并执行加法 \telse//从中间切开,分别执行加法 \t{ _add(p-\u0026gt;left, l, p-\u0026gt;l + mid, k); _add(p-\u0026gt;right, p-\u0026gt;l + mid + 1, r, k); } } updata(p);//更新 }   查询最大值\n1 2 3 4 5 6 7 8 9 10 11 12  double finda(node *p, int l, int r) { if (p-\u0026gt;l == l \u0026amp;\u0026amp; p-\u0026gt;r == r) return p-\u0026gt;max;//若区间正正好完全重合,返回最大值 \tdown(p);//使用子树前先传递标记 \tint mid = (p-\u0026gt;r - p-\u0026gt;l) / 2; if (p-\u0026gt;l \u0026lt;= l \u0026amp;\u0026amp; p-\u0026gt;r \u0026gt;= r)//若区间被完全包含 \t{ if (p-\u0026gt;l + mid \u0026gt;= r) return finda(p-\u0026gt;left, l, r);//待查询区间位于其左子树.查询左子树 \tif (p-\u0026gt;l + mid \u0026lt; l) return finda(p-\u0026gt;right, l, r);//待查询区间位于其右子树,查询右子树 \treturn max(finda(p-\u0026gt;left, l, p-\u0026gt;l + mid), finda(p-\u0026gt;right, p-\u0026gt;l + mid + 1, r));//从中间切开,分别查询,返回最大值 \t} }   构建线段树 其实跟建立普通二叉树一样，只不过多了初始化区间和值以及更新的操作，递归建树即可\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21  node* _build(node *t, int l, int r) { node* p = new node;//建立新节点 \tp-\u0026gt;l = l;//区间左端点 \tp-\u0026gt;r = r;//区右端点 \tp-\u0026gt;father = t;//建立父子关系 \tif (t-\u0026gt;left == NULL) t-\u0026gt;left = p;//若t没有左子树,说明要构建的树为其左子树 \telse t-\u0026gt;right = p;//反之,则为右子树 \tif (l == r)//若为叶子节点 \t{ p-\u0026gt;max = nums[l];//三个一样 \tp-\u0026gt;min = nums[l]; p-\u0026gt;sum = nums[l]; return p;//返回节点地址 \t} int mid = (r - l) / 2; p-\u0026gt;left=_build(p, l, l + mid);//构造左子树 \tp-\u0026gt;right=_build(p, l + mid + 1, r);//构造右子树 \tupdata(p);//更新 \treturn p; }   进阶 区间和 线段树除了可以维护最值，还可以维护区间和\n方法 其实也很简单，每一个结点的值就是其子节点的值之和，单点修改只需减掉原来的在加上修改后的就行了，区间加法只需加上加数×区间长度即可\n查询区间和代码 1 2 3 4 5 6 7 8 9 10 11 12  double findu(node *p, int l, int r) { if (p-\u0026gt;l == l \u0026amp;\u0026amp; p-\u0026gt;r == r) return p-\u0026gt;sum;//若区间正正好完全重合,返回区间和 \tdown(p);//使用子树前先传递标记 \tint mid = (p-\u0026gt;r - p-\u0026gt;l) / 2; if (p-\u0026gt;l \u0026lt;= l \u0026amp;\u0026amp; p-\u0026gt;r \u0026gt;= r)//若区间被完全包含 \t{ if (p-\u0026gt;l + mid \u0026gt;= r) return findu(p-\u0026gt;left, l, r);//若待查询区间位于其左子树,查询左子树 \tif (p-\u0026gt;l + mid \u0026lt; l) return findu(p-\u0026gt;right, l, r);//若待查询区间位于其右子树,查询右子树 \treturn findu(p-\u0026gt;left, l, p-\u0026gt;l + mid) + findu(p-\u0026gt;right, p-\u0026gt;l + mid + 1, r);//从中间切开,分别查询,返回和 \t} }   更新代码 1 2 3 4 5 6  void updata(node *p) { p-\u0026gt;max = max(p-\u0026gt;left-\u0026gt;max, p-\u0026gt;right-\u0026gt;max);//更新最大值 \tp-\u0026gt;min = min(p-\u0026gt;left-\u0026gt;min, p-\u0026gt;right-\u0026gt;min);//更新最小值 \tp-\u0026gt;sum = p-\u0026gt;left-\u0026gt;sum + p-\u0026gt;right-\u0026gt;sum;//更新区间和 }   区间乘法 线段树除了可以进行区间加法，还可以进行区间乘法\n方法  进行区间乘法时，最大值，最小值 都只需乘上乘数即可，然后再修改乘法标记。 此处注意，传递标记时要在修改子节点乘法标记的同时将加法标记乘以乘数，然后加上父节点的加法标记，即先乘后加原则  传递标记代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48  void down(node* p) { if (p-\u0026gt;lazy_add == 0 \u0026amp;\u0026amp; p-\u0026gt;lazy_multiply == 1) return;//若没有标记,传递啥? \tif (p-\u0026gt;left-\u0026gt;l == p-\u0026gt;left-\u0026gt;r)//若为叶子结点,无需修改其标记(根本就没标记...) \t{ p-\u0026gt;left-\u0026gt;max *= p-\u0026gt;lazy_multiply;//先乘后加 \tp-\u0026gt;left-\u0026gt;min *= p-\u0026gt;lazy_multiply; p-\u0026gt;left-\u0026gt;sum *= p-\u0026gt;lazy_multiply; p-\u0026gt;left-\u0026gt;max += p-\u0026gt;lazy_add; p-\u0026gt;left-\u0026gt;min += p-\u0026gt;lazy_add; p-\u0026gt;left-\u0026gt;sum += p-\u0026gt;lazy_add; } else//否则,先修改标记,再修改值 \t{ p-\u0026gt;left-\u0026gt;lazy_multiply *= p-\u0026gt;lazy_multiply;//先乘后加 \tp-\u0026gt;left-\u0026gt;lazy_add *= p-\u0026gt;lazy_multiply; p-\u0026gt;left-\u0026gt;lazy_add += p-\u0026gt;lazy_add; p-\u0026gt;left-\u0026gt;max *= p-\u0026gt;lazy_multiply; p-\u0026gt;left-\u0026gt;min *= p-\u0026gt;lazy_multiply; p-\u0026gt;left-\u0026gt;sum *= p-\u0026gt;lazy_multiply; p-\u0026gt;left-\u0026gt;max += p-\u0026gt;lazy_add; p-\u0026gt;left-\u0026gt;min += p-\u0026gt;lazy_add; p-\u0026gt;left-\u0026gt;sum += p-\u0026gt;lazy_add * (p-\u0026gt;left-\u0026gt;r - p-\u0026gt;left-\u0026gt;l + 1);//区间和增加传递的标记乘以区间节点个数 \t} if (p-\u0026gt;right-\u0026gt;l == p-\u0026gt;right-\u0026gt;r)//同上(本来就是复制下来的...) \t{ p-\u0026gt;right-\u0026gt;max *= p-\u0026gt;lazy_multiply; p-\u0026gt;right-\u0026gt;min *= p-\u0026gt;lazy_multiply; p-\u0026gt;right-\u0026gt;sum *= p-\u0026gt;lazy_multiply; p-\u0026gt;right-\u0026gt;max += p-\u0026gt;lazy_add; p-\u0026gt;right-\u0026gt;min += p-\u0026gt;lazy_add; p-\u0026gt;right-\u0026gt;sum += p-\u0026gt;lazy_add; } else { p-\u0026gt;right-\u0026gt;lazy_multiply *= p-\u0026gt;lazy_multiply; p-\u0026gt;right-\u0026gt;lazy_add *= p-\u0026gt;lazy_multiply; p-\u0026gt;right-\u0026gt;lazy_add += p-\u0026gt;lazy_add; p-\u0026gt;right-\u0026gt;max *=p-\u0026gt;lazy_multiply; p-\u0026gt;right-\u0026gt;min *=p-\u0026gt;lazy_multiply; p-\u0026gt;right-\u0026gt;sum *=p-\u0026gt;lazy_multiply; p-\u0026gt;right-\u0026gt;max +=p-\u0026gt;lazy_add; p-\u0026gt;right-\u0026gt;min +=p-\u0026gt;lazy_add; p-\u0026gt;right-\u0026gt;sum +=p-\u0026gt;lazy_add * (p-\u0026gt;right-\u0026gt;r - p-\u0026gt;right-\u0026gt;l + 1); } p-\u0026gt;lazy_add = 0;//删除加法标记 \tp-\u0026gt;lazy_multiply = 1;//删除乘法标记 }   区间乘法代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35  void _multiply(node *p, int l, int r, double k) { if (p-\u0026gt;l == l \u0026amp;\u0026amp; p-\u0026gt;r == r)//若区间完全重合 \t{ if (p-\u0026gt;l != p-\u0026gt;r) p-\u0026gt;lazy_multiply *= k;//若不是叶子结点,更新乘法标记 \tif (k \u0026gt;= 0)//若乘数为正 \t{ p-\u0026gt;max *= k;//原来最大的还是最大的 \tp-\u0026gt;min *= k;//原来最小的还是最小的 \t} else { double max = p-\u0026gt;max, min = p-\u0026gt;min;//暂时储存 \tp-\u0026gt;max = min * k;//原来最大的符号相反后变成最小的 \tp-\u0026gt;min = max * k;//原来最小的符号相反后变为最大的 \t} p-\u0026gt;sum *= k;//更新区间和 \tp-\u0026gt;lazy_add *= k;//更新加法标记(下面每个数要加的数也乘了k) \treturn; } int mid = (p-\u0026gt;r - p-\u0026gt;l) / 2; if (p-\u0026gt;l \u0026lt;= l \u0026amp;\u0026amp; p-\u0026gt;r \u0026gt;= r)//若区间被完全包含 \t{ down(p);//使用子节点前先更新标记 \tif (p-\u0026gt;l + mid \u0026gt;= r) _multiply(p-\u0026gt;left, l, r, k);//若待操作区间完全位于左子树,向左子树查询并进行区间乘法 \telse if (p-\u0026gt;l + mid \u0026lt; l) _multiply(p-\u0026gt;right, l, r, k);//若待操作区间完全位于右子树,向右子树查询并进行区间乘法 \telse//从中间切开,分别进行操作 \t{ _multiply(p-\u0026gt;left, l, p-\u0026gt;l + mid, k); _multiply(p-\u0026gt;right, p-\u0026gt;l + mid + 1, r, k); } } updata(p);//更新 }   完整代码 指针版(理解下蒟蒻的思路) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354  #include\u0026lt;iostream\u0026gt;#include\u0026lt;vector\u0026gt;#include\u0026lt;algorithm\u0026gt;using namespace std; #define inf 0x3f3f3f3f class tree { public: struct node { node* father;//父节点 \tnode* left;//左子树 \tnode* right;//右子树 \tdouble max;//区间最大值 \tdouble min;//区间最小值 \tdouble sum;//区间和 \tint l, r;//区间端点 \tdouble lazy_add;//加法标记 \tdouble lazy_multiply;//乘法标记 \tnode()//初始化 \t{ father = NULL; left = NULL; right = NULL; l = -1; r = -1; max = -inf; min = inf; sum = inf; lazy_add = 0;//即什么都没加 \tlazy_multiply = 1;//即什么都没乘 \t} }; ~tree()//删除整棵树 \t{ d_t(root); } //---------------------------------------------构造线段树-------------------------------------------------- \tvoid build(vector\u0026lt;double\u0026gt; num) { d_t(root);//删除旧树 \tnums = num;//赋新值 \tint size = nums.size() - 1; int mid = size / 2; root = new node; root-\u0026gt;l = 0;//根节点区间左端为0 \troot-\u0026gt;r = size;//根节点区间右端为size \t_build(root, 0, mid);//构建左子树 \t_build(root, mid + 1, size);//构建右子树 \tupdata(root);//更新根节点的值 \t} //-----------------------------------------------查询----------------------------------------------------- \tdouble find(int l, int r, string mode) { if (mode == \u0026#34;max\u0026#34;)//返回区间最大值 \treturn finda(root, l, r); if (mode == \u0026#34;min\u0026#34;)//返回区间最小值 \treturn findi(root, l, r); if (mode == \u0026#34;sum\u0026#34;)//返回区间和 \treturn findu(root, l, r); } //----------------------------------------------区间加法-------------------------------------------------- \tvoid add(int l, int r, double k)//区间l~r内每个数加k \t{ _add(root, l, r, k); } //----------------------------------------------区间减法-------------------------------------------------- \tvoid multiply(int l, int r, double k)//区间l~r内.每个数乘k \t{ _multiply(root, l, r, k); } //--------------------------------------------输出整个区间------------------------------------------------- \tvoid out()//输出线段树包含的数 \t{ _out(root); cout \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; } private: node* root;//根节点 \tvector\u0026lt;double\u0026gt;nums;//数据 \t//----------------------------------------------删除------------------------------------------------------ \tvoid d_t(node* p) { if (p == NULL) return;//啥毛没有,咋删? \tif (p-\u0026gt;left != NULL) d_t(p-\u0026gt;left);//删除左子树 \tif (p-\u0026gt;right != NULL) d_t(p-\u0026gt;right);//删除右子树 \tdelete p;//删除自己 \t} //----------------------------------------------更新-------------------------------------------------------- \tvoid updata(node *p) { p-\u0026gt;max = max(p-\u0026gt;left-\u0026gt;max, p-\u0026gt;right-\u0026gt;max);//更新最大值 \tp-\u0026gt;min = min(p-\u0026gt;left-\u0026gt;min, p-\u0026gt;right-\u0026gt;min);//更新最小值 \tp-\u0026gt;sum = p-\u0026gt;left-\u0026gt;sum + p-\u0026gt;right-\u0026gt;sum;//更新区间和 \t} //----------------------------------------------构造--------------------------------------------------------- \tnode* _build(node *t, int l, int r) { node* p = new node;//建立新节点 \tp-\u0026gt;l = l;//区间左端点 \tp-\u0026gt;r = r;//区右端点 \tp-\u0026gt;father = t;//建立父子关系 \tif (t-\u0026gt;left == NULL) t-\u0026gt;left = p;//若t没有左子树,说明要构建的树为其左子树 \telse t-\u0026gt;right = p;//反之,则为右子树 \tif (l == r)//若为叶子节点 \t{ p-\u0026gt;max = nums[l];//三个一样 \tp-\u0026gt;min = nums[l]; p-\u0026gt;sum = nums[l]; return p;//返回节点地址 \t} int mid = (r - l) / 2; p-\u0026gt;left=_build(p, l, l + mid);//构造左子树 \tp-\u0026gt;right=_build(p, l + mid + 1, r);//构造右子树 \tupdata(p);//更新 \treturn p; } //---------------------------------------------传递标记--------------------------------------------------- \tvoid down(node* p) { if (p-\u0026gt;lazy_add == 0 \u0026amp;\u0026amp; p-\u0026gt;lazy_multiply == 1) return;//若没有标记,传递啥? \tif (p-\u0026gt;left-\u0026gt;l == p-\u0026gt;left-\u0026gt;r)//若为叶子结点,无需修改其标记(根本就没标记...) \t{ p-\u0026gt;left-\u0026gt;max *= p-\u0026gt;lazy_multiply;//先乘后加 \tp-\u0026gt;left-\u0026gt;min *= p-\u0026gt;lazy_multiply; p-\u0026gt;left-\u0026gt;sum *= p-\u0026gt;lazy_multiply; p-\u0026gt;left-\u0026gt;max += p-\u0026gt;lazy_add; p-\u0026gt;left-\u0026gt;min += p-\u0026gt;lazy_add; p-\u0026gt;left-\u0026gt;sum += p-\u0026gt;lazy_add; } else//否则,先修改标记,再修改值 \t{ p-\u0026gt;left-\u0026gt;lazy_multiply *= p-\u0026gt;lazy_multiply;//先乘后加 \tp-\u0026gt;left-\u0026gt;lazy_add *= p-\u0026gt;lazy_multiply; p-\u0026gt;left-\u0026gt;lazy_add += p-\u0026gt;lazy_add; p-\u0026gt;left-\u0026gt;max *= p-\u0026gt;lazy_multiply; p-\u0026gt;left-\u0026gt;min *= p-\u0026gt;lazy_multiply; p-\u0026gt;left-\u0026gt;sum *= p-\u0026gt;lazy_multiply; p-\u0026gt;left-\u0026gt;max += p-\u0026gt;lazy_add; p-\u0026gt;left-\u0026gt;min += p-\u0026gt;lazy_add; p-\u0026gt;left-\u0026gt;sum += p-\u0026gt;lazy_add * (p-\u0026gt;left-\u0026gt;r - p-\u0026gt;left-\u0026gt;l + 1);//区间和增加传递的标记乘以区间节点个数 \t} if (p-\u0026gt;right-\u0026gt;l == p-\u0026gt;right-\u0026gt;r)//同上(本来就是复制下来的...) \t{ p-\u0026gt;right-\u0026gt;max *= p-\u0026gt;lazy_multiply; p-\u0026gt;right-\u0026gt;min *= p-\u0026gt;lazy_multiply; p-\u0026gt;right-\u0026gt;sum *= p-\u0026gt;lazy_multiply; p-\u0026gt;right-\u0026gt;max += p-\u0026gt;lazy_add; p-\u0026gt;right-\u0026gt;min += p-\u0026gt;lazy_add; p-\u0026gt;right-\u0026gt;sum += p-\u0026gt;lazy_add; } else { p-\u0026gt;right-\u0026gt;lazy_multiply *= p-\u0026gt;lazy_multiply; p-\u0026gt;right-\u0026gt;lazy_add *= p-\u0026gt;lazy_multiply; p-\u0026gt;right-\u0026gt;lazy_add += p-\u0026gt;lazy_add; p-\u0026gt;right-\u0026gt;max *=p-\u0026gt;lazy_multiply; p-\u0026gt;right-\u0026gt;min *=p-\u0026gt;lazy_multiply; p-\u0026gt;right-\u0026gt;sum *=p-\u0026gt;lazy_multiply; p-\u0026gt;right-\u0026gt;max +=p-\u0026gt;lazy_add; p-\u0026gt;right-\u0026gt;min +=p-\u0026gt;lazy_add; p-\u0026gt;right-\u0026gt;sum +=p-\u0026gt;lazy_add * (p-\u0026gt;right-\u0026gt;r - p-\u0026gt;right-\u0026gt;l + 1); } p-\u0026gt;lazy_add = 0;//删除加法标记 \tp-\u0026gt;lazy_multiply = 1;//删除乘法标记 \t} //------------------------------------------------输出---------------------------------------------------- \tvoid _out(node* p) { if (p-\u0026gt;l == p-\u0026gt;r)//若为叶子节点,输出 \t{ cout \u0026lt;\u0026lt; p-\u0026gt;max \u0026lt;\u0026lt; \u0026#34; \u0026#34;; return; } down(p);//使用子树前先传递标记 \t_out(p-\u0026gt;left);//输出左子树 \t_out(p-\u0026gt;right);//输出右子树 \t} //---------------------------------------------查询区间最大值---------------------------------------------- \tdouble finda(node *p, int l, int r) { if (p-\u0026gt;l == l \u0026amp;\u0026amp; p-\u0026gt;r == r) return p-\u0026gt;max;//若区间正正好完全重合,返回最大值 \tdown(p);//使用子树前先传递标记 \tint mid = (p-\u0026gt;r - p-\u0026gt;l) / 2; if (p-\u0026gt;l \u0026lt;= l \u0026amp;\u0026amp; p-\u0026gt;r \u0026gt;= r)//若区间被完全包含 \t{ if (p-\u0026gt;l + mid \u0026gt;= r) return finda(p-\u0026gt;left, l, r);//待查询区间位于其左子树.查询左子树 \tif (p-\u0026gt;l + mid \u0026lt; l) return finda(p-\u0026gt;right, l, r);//待查询区间位于其右子树,查询右子树 \treturn max(finda(p-\u0026gt;left, l, p-\u0026gt;l + mid), finda(p-\u0026gt;right, p-\u0026gt;l + mid + 1, r));//从中间切开,分别查询,返回最大值 \t} return -inf;//防止破坏 \t} //--------------------------------------------查询区间最小值----------------------------------------------- \tdouble findi(node *p, int l, int r) { if (p-\u0026gt;l == l \u0026amp;\u0026amp; p-\u0026gt;r == r) return p-\u0026gt;min;//若区间正正好完全重合,返回最小值 \tdown(p);//使用子树前先传递标记 \tint mid = (p-\u0026gt;r - p-\u0026gt;l) / 2; if (p-\u0026gt;l \u0026lt;= l \u0026amp;\u0026amp; p-\u0026gt;r \u0026gt;= r)//若区间被完全包含 \t{ if (p-\u0026gt;l + mid \u0026gt;= r) return findi(p-\u0026gt;left, l, r);//待查询区间位于其左子树,查询左子树 \tif (p-\u0026gt;l + mid \u0026lt; l) return findi(p-\u0026gt;right, l, r);//待查询区间位于其右子树,查询右子树 \treturn min(findi(p-\u0026gt;left, l, p-\u0026gt;l + mid), findi(p-\u0026gt;right, p-\u0026gt;l + mid + 1, r));//从中间切开,分别查询,返回最小值 \t} return inf;//防止破坏 \t} //----------------------------------------------查询区间和------------------------------------------------ \tdouble findu(node *p, int l, int r) { if (p-\u0026gt;l == l \u0026amp;\u0026amp; p-\u0026gt;r == r) return p-\u0026gt;sum;//若区间正正好完全重合,返回区间和 \tdown(p);//使用子树前先传递标记 \tint mid = (p-\u0026gt;r - p-\u0026gt;l) / 2; if (p-\u0026gt;l \u0026lt;= l \u0026amp;\u0026amp; p-\u0026gt;r \u0026gt;= r)//若区间被完全包含 \t{ if (p-\u0026gt;l + mid \u0026gt;= r) return findu(p-\u0026gt;left, l, r);//若待查询区间位于其左子树,查询左子树 \tif (p-\u0026gt;l + mid \u0026lt; l) return findu(p-\u0026gt;right, l, r);//若待查询区间位于其右子树,查询右子树 \treturn findu(p-\u0026gt;left, l, p-\u0026gt;l + mid) + findu(p-\u0026gt;right, p-\u0026gt;l + mid + 1, r);//从中间切开,分别查询,返回和 \t} return inf;//防止破坏 \t} //---------------------------------------------区间加法--------------------------------------------------- \tvoid _add(node *p, int l, int r, double k) { if (p-\u0026gt;l == l \u0026amp;\u0026amp; p-\u0026gt;r == r)//若区间完全重合 \t{ if (p-\u0026gt;l != p-\u0026gt;r) p-\u0026gt;lazy_add += k;//若不是叶子结点,更新加法标记 \tp-\u0026gt;min += k;//更新区间最小值 \tp-\u0026gt;max += k;//更新区间最大值 \tp-\u0026gt;sum += k * (p-\u0026gt;r - p-\u0026gt;l + 1);//更新区间和 \treturn; } int mid = (p-\u0026gt;r - p-\u0026gt;l) / 2; if (p-\u0026gt;l \u0026lt;= l \u0026amp;\u0026amp; p-\u0026gt;r \u0026gt;= r)//若区间被包含 \t{ down(p);//使用子树前先传递标记 \tif (p-\u0026gt;l + mid \u0026gt;= r) _add(p-\u0026gt;left, l, r, k);//若区间完全位于其左子树,向左子树查找区间l~r并执行加法 \telse if (p-\u0026gt;l + mid \u0026lt; l) _add(p-\u0026gt;right, l, r, k);//若区间完全位于其右子树,向右子树查找区间l~r并执行加法 \telse//从中间切开,分别执行加法 \t{ _add(p-\u0026gt;left, l, p-\u0026gt;l + mid, k); _add(p-\u0026gt;right, p-\u0026gt;l + mid + 1, r, k); } } updata(p);//更新 \t} //----------------------------------------------区间乘法-------------------------------------------------- \tvoid _multiply(node *p, int l, int r, double k) { if (p-\u0026gt;l == l \u0026amp;\u0026amp; p-\u0026gt;r == r)//若区间完全重合 \t{ if (p-\u0026gt;l != p-\u0026gt;r) p-\u0026gt;lazy_multiply *= k;//若不是叶子结点,更新乘法标记 \tif (k \u0026gt;= 0)//若乘数为正 \t{ p-\u0026gt;max *= k;//原来最大的还是最大的 \tp-\u0026gt;min *= k;//原来最小的还是最小的 \t} else { double max = p-\u0026gt;max, min = p-\u0026gt;min;//暂时储存 \tp-\u0026gt;max = min * k;//原来最大的符号相反后变成最小的 \tp-\u0026gt;min = max * k;//原来最小的符号相反后变为最大的 \t} p-\u0026gt;sum *= k;//更新区间和 \tp-\u0026gt;lazy_add *= k;//更新加法标记(下面每个数要加的数也乘了k) \treturn; } int mid = (p-\u0026gt;r - p-\u0026gt;l) / 2; if (p-\u0026gt;l \u0026lt;= l \u0026amp;\u0026amp; p-\u0026gt;r \u0026gt;= r)//若区间被完全包含 \t{ down(p);//使用子节点前先更新标记 \tif (p-\u0026gt;l + mid \u0026gt;= r) _multiply(p-\u0026gt;left, l, r, k);//若待操作区间完全位于左子树,向左子树查询并进行区间乘法 \telse if (p-\u0026gt;l + mid \u0026lt; l) _multiply(p-\u0026gt;right, l, r, k);//若待操作区间完全位于右子树,向右子树查询并进行区间乘法 \telse//从中间切开,分别进行操作 \t{ _multiply(p-\u0026gt;left, l, p-\u0026gt;l + mid, k); _multiply(p-\u0026gt;right, p-\u0026gt;l + mid + 1, r, k); } } updata(p);//更新 \t} }; tree Te; int main() { char D; aaa:cin \u0026gt;\u0026gt; D; switch (D) { case \u0026#39;B\u0026#39;://构造 \t{ int n; cin \u0026gt;\u0026gt; n; vector\u0026lt;double\u0026gt; muns; double num; for (int i = 0; i \u0026lt; n; i++) { cin \u0026gt;\u0026gt; num; muns.push_back(num); } Te.build(muns); break; } case \u0026#39;N\u0026#39;://查询区间最小值 \t{ int l, r; cin \u0026gt;\u0026gt; l \u0026gt;\u0026gt; r; cout \u0026lt;\u0026lt; Te.find(l, r, \u0026#34;min\u0026#34;) \u0026lt;\u0026lt; endl; break; } case \u0026#39;M\u0026#39;://查询区间和 \t{ int l, r; cin \u0026gt;\u0026gt; l \u0026gt;\u0026gt; r; cout \u0026lt;\u0026lt; Te.find(l, r, \u0026#34;sum\u0026#34;) \u0026lt;\u0026lt; endl; break; } case \u0026#39;X\u0026#39;://查询区间最大值 \t{ int l, r; cin \u0026gt;\u0026gt; l \u0026gt;\u0026gt; r; cout \u0026lt;\u0026lt; Te.find(l, r, \u0026#34;max\u0026#34;) \u0026lt;\u0026lt; endl; break; } case \u0026#39;J\u0026#39;://区间加法 \t{ int l, r; double k; cin \u0026gt;\u0026gt; l \u0026gt;\u0026gt; r \u0026gt;\u0026gt; k; Te.add(l, r, k); break; } case \u0026#39;C\u0026#39;://区间乘法 \t{ int l, r; double k; cin \u0026gt;\u0026gt; l \u0026gt;\u0026gt; r \u0026gt;\u0026gt; k; Te.multiply(l, r, k); break; } case \u0026#39;O\u0026#39;://输出 \t{ Te.out(); break; } case \u0026#39;E\u0026#39;://结束 \t{ return 0; } } goto aaa; return 0; }   数组版(知道能拿数组写就好) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281  #include\u0026lt;iostream\u0026gt;#include\u0026lt;vector\u0026gt;#include\u0026lt;algorithm\u0026gt;using namespace std; #define inf 0x3f3f3f3f class tree { public: struct node { double max; double min; double sum; int l, r; double lazy_add; double lazy_multiply; node() { l = -1; r = -1; max = -inf; min = inf; sum = inf; lazy_add = 0; lazy_multiply = 1; } }T[10000];//T[n*2+1]是T[n]的左子树,T[n*2+2]是T[n]的右子树 \tvoid build(vector\u0026lt;double\u0026gt; num) { nums = num; _build(0, 0, nums.size() - 1); } double find(int l, int r, string mode) { if (mode == \u0026#34;max\u0026#34;) return finda(0, l, r); if (mode == \u0026#34;min\u0026#34;) return findi(0, l, r); if (mode == \u0026#34;sum\u0026#34;) return findu(0, l, r); } void add(int l, int r, double k) { _add(0, l, r, k); } void multiply(int l, int r, double k) { _multiply(0, l, r, k); } private: vector\u0026lt;double\u0026gt;nums; void updata(int n) { T[n].max = max(T[n * 2 + 1].max, T[n * 2 + 2].max); T[n].min = min(T[n * 2 + 1].min, T[n * 2 + 2].min); T[n].sum = T[n * 2 + 1].sum + T[n * 2 + 2].sum; } void _build(int n, int l, int r) { T[n].l = l; T[n].r = r; if (l == r) { T[n].max = nums[l]; T[n].min = nums[l]; T[n].sum = nums[l]; return; } int mid = (r - l) / 2; _build(n * 2 + 1, l, l + mid); _build(n * 2 + 2, l + mid + 1, r); updata(n); } void down(int n) { if (T[n * 2 + 1].l == T[n * 2 + 1].r) { T[n * 2 + 1].max *= T[n].lazy_multiply; T[n * 2 + 1].min *= T[n].lazy_multiply; T[n * 2 + 1].sum *= T[n].lazy_multiply; T[n * 2 + 1].max += T[n].lazy_add; T[n * 2 + 1].min += T[n].lazy_add; T[n * 2 + 1].sum += T[n].lazy_add; } else { T[n * 2 + 1].lazy_multiply *= T[n].lazy_multiply; T[n * 2 + 1].lazy_add *= T[n].lazy_multiply; T[n * 2 + 1].lazy_add += T[n].lazy_add; T[n * 2 + 1].max *= T[n].lazy_multiply; T[n * 2 + 1].min *= T[n].lazy_multiply; T[n * 2 + 1].sum *= T[n].lazy_multiply; T[n * 2 + 1].max += T[n].lazy_add; T[n * 2 + 1].min += T[n].lazy_add; T[n * 2 + 1].sum += T[n].lazy_add * (T[n * 2 + 1].r - T[n * 2 + 1].l + 1); } if (T[n * 2 + 2].l == T[n * 2 + 2].r) { T[n * 2 + 2].max *= T[n].lazy_multiply; T[n * 2 + 2].min *= T[n].lazy_multiply; T[n * 2 + 2].sum *= T[n].lazy_multiply; T[n * 2 + 2].max += T[n].lazy_add; T[n * 2 + 2].min += T[n].lazy_add; T[n * 2 + 2].sum += T[n].lazy_add; } else { T[n * 2 + 2].lazy_multiply *= T[n].lazy_multiply; T[n * 2 + 2].lazy_add *= T[n].lazy_multiply; T[n * 2 + 2].lazy_add += T[n].lazy_add; T[n * 2 + 2].max *= T[n].lazy_multiply; T[n * 2 + 2].min *= T[n].lazy_multiply; T[n * 2 + 2].sum *= T[n].lazy_multiply; T[n * 2 + 2].max += T[n].lazy_add; T[n * 2 + 2].min += T[n].lazy_add; T[n * 2 + 2].sum += T[n].lazy_add * (T[n * 2 + 2].r - T[n * 2 + 2].l + 1); } T[n].lazy_add = 0; T[n].lazy_multiply = 1; } double finda(int n, int l, int r) { if (T[n].l == l \u0026amp;\u0026amp; T[n].r == r) return T[n].max; down(n); int mid = (T[n].r - T[n].l) / 2; if (T[n].l \u0026lt;= l \u0026amp;\u0026amp; T[n].r \u0026gt;= r) { if (T[n].l + mid \u0026gt;= r) return finda(n * 2 + 1, l, r); if (T[n].l + mid \u0026lt; l) return finda(n * 2 + 2, l, r); return max(finda(n * 2 + 1, l, T[n].l + mid), finda(n * 2 + 2, T[n].l + mid + 1, r)); } return -inf; } double findi(int n, int l, int r) { if (T[n].l == l \u0026amp;\u0026amp; T[n].r == r) return T[n].min; down(n); int mid = (T[n].r - T[n].l) / 2; if (T[n].l \u0026lt;= l \u0026amp;\u0026amp; T[n].r \u0026gt;= r) { if (T[n].l + mid \u0026gt;= r) return findi(n * 2 + 1, l, r); if (T[n].l + mid \u0026lt; l) return findi(n * 2 + 2, l, r); return min(findi(n * 2 + 1, l, T[n].l + mid), findi(n * 2 + 2, T[n].l + mid + 1, r)); } return inf; } double findu(int n, int l, int r) { if (T[n].l == l \u0026amp;\u0026amp; T[n].r == r) return T[n].sum; down(n); int mid = (T[n].r - T[n].l) / 2; if (T[n].l \u0026lt;= l \u0026amp;\u0026amp; T[n].r \u0026gt;= r) { if (T[n].l + mid \u0026gt;= r) return findu(n * 2 + 1, l, r); if (T[n].l + mid \u0026lt; l) return findu(n * 2 + 2, l, r); return findu(n * 2 + 1, l, T[n].l + mid) + findu(n * 2 + 2, T[n].l + mid + 1, r); } return inf; } void _add(int n, int l, int r, double k) { if (T[n].l == l \u0026amp;\u0026amp; T[n].r == r) { if (T[n].l != T[n].r) T[n].lazy_add += k; T[n].min += k; T[n].max += k; T[n].sum += k * (T[n].r - T[n].l + 1); return; } int mid = (T[n].r - T[n].l) / 2; if (T[n].l \u0026lt;= l \u0026amp;\u0026amp; T[n].r \u0026gt;= r) { down(n); if (T[n].l + mid \u0026gt;= r) _add(n * 2 + 1, l, r, k); else if (T[n].l + mid \u0026lt; l) _add(n * 2 + 2, l, r, k); else { _add(n * 2 + 1, l, T[n].l + mid, k); _add(n * 2 + 2, T[n].l + mid + 1, r, k); } } updata(n); } void _multiply(int n, int l, int r, double k) { if (T[n].l == l \u0026amp;\u0026amp; T[n].r == r) { if (T[n].l != T[n].r)T[n].lazy_multiply *= k; if (k \u0026gt;= 0) { T[n].max *= k; T[n].min *= k; } else { double max = T[n].max, min = T[n].min; T[n].max = min * k; T[n].min = max * k; } T[n].sum *= k; T[n].lazy_add *= k; return; } int mid = (T[n].r - T[n].l) / 2; if (T[n].l \u0026lt;= l \u0026amp;\u0026amp; T[n].r \u0026gt;= r) { down(n); if (T[n].l + mid \u0026gt;= r) _multiply(n * 2 + 1, l, r, k); else if (T[n].l + mid \u0026lt; l) _multiply(n * 2 + 2, l, r, k); else { _multiply(n * 2 + 1, l, T[n].l + mid, k); _multiply(n * 2 + 2, T[n].l + mid + 1, r, k); } } updata(n); } }; tree Te; int main() { char D; aaa:cin \u0026gt;\u0026gt; D; switch (D) { case \u0026#39;B\u0026#39;: { int n; cin \u0026gt;\u0026gt; n; vector\u0026lt;double\u0026gt; muns; double num; for (int i = 0; i \u0026lt; n; i++) { cin \u0026gt;\u0026gt; num; muns.push_back(num); } Te.build(muns); break; } case \u0026#39;N\u0026#39;: { int l, r; cin \u0026gt;\u0026gt; l \u0026gt;\u0026gt; r; cout \u0026lt;\u0026lt; Te.find(l, r, \u0026#34;min\u0026#34;) \u0026lt;\u0026lt; endl; break; } case \u0026#39;M\u0026#39;: { int l, r; cin \u0026gt;\u0026gt; l \u0026gt;\u0026gt; r; cout \u0026lt;\u0026lt; Te.find(l, r, \u0026#34;sum\u0026#34;) \u0026lt;\u0026lt; endl; break; } case \u0026#39;X\u0026#39;: { int l, r; cin \u0026gt;\u0026gt; l \u0026gt;\u0026gt; r; cout \u0026lt;\u0026lt; Te.find(l, r, \u0026#34;max\u0026#34;) \u0026lt;\u0026lt; endl; break; } case \u0026#39;J\u0026#39;: { int l, r; double k; cin \u0026gt;\u0026gt; l \u0026gt;\u0026gt; r \u0026gt;\u0026gt; k; Te.add(l, r, k); break; } case \u0026#39;C\u0026#39;: { int l, r; double k; cin \u0026gt;\u0026gt; l \u0026gt;\u0026gt; r \u0026gt;\u0026gt; k; Te.multiply(l, r, k); } } goto aaa; return 0; }   压行版(最好多打几遍背下来) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98  #include\u0026lt;iostream\u0026gt;#include\u0026lt;algorithm\u0026gt;using namespace std; int la[100000];//加法标记 int lm[100000];//乘法标记 int x[100000];//节点最大值 int n[100000];//节点最小值 int s[100000];//节点区间和 int ln[100000];//左端点 int rn[100000];//右端点 int num[100000];//临时数据 #define ls (p\u0026lt;\u0026lt;1)//左儿子 #define rs (ls|1)//右儿子 #define mid (ln[p]+rn[p]\u0026gt;\u0026gt;1) #define a la[p]//当前节点加法标记 #define m lm[p]//当前节点减法标记 inline void updata(int p) { x[p] = max(x[ls], x[rs]); n[p] = min(n[ls], n[rs]); s[p] = s[ls] + s[rs]; } void build(int p, int l, int r) { ln[p] = l; rn[p] = r; if (l == r) { x[p] = n[p] = s[p] = num[l]; return; } build(ls, l, mid); build(rs, mid + 1, r); updata(p); } inline void down(int p) { if (m != 1) { la[ls] *= m; lm[ls] *= m; la[rs] *= m; lm[rs] *= m; x[ls] *= m; n[ls] *= m; s[ls] *= m; x[rs] *= m; n[rs] *= m; s[rs] *= m; lm[p] = 1; } if (a != 0) { la[ls] += a; la[rs] += a; x[ls] += a; n[ls] += a; s[ls] += (rn[ls] - ln[ls] + 1) * a; x[rs] += a; n[rs] += a; s[rs] += (rn[rs] - ln[rs] + 1) * a; a = 0; } } void change(int p, int l, int r, int add/*加法*/, int mut/*乘法*/)//乘法优先 { if (ln[p] == l \u0026amp;\u0026amp; rn[p] == r) { x[p] *= mut; n[p] *= mut; s[p] *= mut; x[p] += add; n[p] += add; s[p] += (rn[p] - ln[p] + 1) * add; if (l != r) { a *= mut; a += add; m *= mut; } return; } down(p); if (l \u0026gt; mid) change(rs, l, r, add, mut); else if (r \u0026lt;= mid) change(ls, l, r, add, mut); else { change(ls, l, mid, add, mut); change(rs, mid + 1, r, add, mut); } updata(p); } int mx(int p, int l, int r) { if (ln[p] == l \u0026amp;\u0026amp; rn[p] == r) return x[p]; down(p); if (l \u0026gt; mid) return mx(rs, l, r); if (r \u0026lt;= mid) return mx(ls, l, r); return max(mx(ls, l, mid), mx(rs, mid + 1, r)); } int mn(int p, int l, int r) { if (ln[p] == l \u0026amp;\u0026amp; rn[p] == r) return n[p]; down(p); if (l \u0026gt; mid) return mn(rs, l, r); if (r \u0026lt;= mid) return mn(ls, l, r); return min(mn(ls, l, mid), mn(rs, mid + 1, r)); } int sum(int p, int l, int r) { if (ln[p] == l \u0026amp;\u0026amp; rn[p] == r) return s[p]; down(p); if (l \u0026gt; mid) return sum(rs, l, r); if (r \u0026lt;= mid) return sum(ls, l, r); return sum(ls, l, mid) + sum(rs, mid + 1, r); } int main() { int n; cin \u0026gt;\u0026gt; n; for (int i = 0; i \u0026lt; n; i++) cin \u0026gt;\u0026gt; num[i]; build(1, 0, n - 1); //change(1, 0, n - 1, 1, 2); \tcout \u0026lt;\u0026lt; sum(1, 0, n - 1); return 0; }   ","date":"2020-04-26T00:00:00Z","image":"https://timgsa.baidu.com/timg?image\u0026quality=80\u0026size=b9999_10000\u0026sec=1587878842959\u0026di=d865670296e9efbf79ee1fe7fa5166cb\u0026imgtype=0\u0026src=http%3A%2F%2Fmedia.hihocoder.com%2Fproblem_images%2F20141108%2F14154249931829.png","permalink":"https://gbwater.ga/p/%E7%BA%BF%E6%AE%B5%E6%A0%91/","title":"线段树"},{"content":"重中之重 运行需安装 .NET 4.7.2\n简介  实现Windows下在指定时间关机 支持指定多个关机时间点 在到达关机时间后，弹出窗口提示 在弹出的窗口支持延长时间操作 \u0026hellip;\u0026hellip;  v 1.2更新内容 添加了对多个关机时间的支持\n使用说明  下载后编辑setting.txt完成时间配置 运行start.vbs 在弹出关机提示窗口后可以执行延长时间操作  特别说明  时间填写可以不按照时间顺序，一个一行，24小时制，小时与分钟间用冒号隔开且不可有空格 时间填写样例以预先在文件中给出 请不要直接运行 main.exe ，除非你想看到一个大黑框 请不要运行 auto_shut.exe ，这是关机的提示窗口 程序文件在 “auto_shut” 文件夹里， “自动关机2” 中是窗体的源代码  程序运行截图 开源声明 此程序的所有源代码都公开 这不一起和程序文件打包放上去了\n如果使用有问题，可以自己解决，也可以戳我 联系方式在下面\n本蒟蒻会尽力解决问题，但是因为此程序的问题导致的损失本蒟蒻概不负责 强行甩锅\n 开源是一种美德，也是一种实力的象征，同时是说明程序功能的最好方法\n 下载链接 百度网盘 提取码：m860\n","date":"2020-04-25T00:00:00Z","image":"https://s3.ax1x.com/2021/02/11/yBlcIP.jpg","permalink":"https://gbwater.ga/p/%E5%AE%9A%E6%97%B6%E5%85%B3%E6%9C%BA/","title":"定时关机"},{"content":"简介  实现Windows下根据时间表自动将指定目录中的文件备份到指定目录 说白了就是根据课程表将课件分类复制到各科目对应的文件夹(需要指定) 可选预先扫描目标文件夹以跳过重复文件 可选保存文件信息以减少扫描时间(就是复制过的课件不再复制) 可选彻底排除重复文件(就是即使有两个没复制过的但仅文件名不同的课件也只会复制其中一个) 性能优化，cpu占用低于1%(环境: Intel core i7-3820@3.6G × 4) 支持排除文件(可以指定不复制的文件,比如桌面上的一堆lnk之类) \u0026hellip;\u0026hellip;  v 2.6更新内容  添加了对课程表时间乱序的支持(就是可以不按照时间顺序填写了) 添加了对桌面文件夹的快捷选择支持  使用说明  下载后编辑settings.txt完成时间配置 在程序所在目录下建立时间表：星期一：1.txt 星期二：2.txt ……以此类推 完成时间表的配置 运行start.vbs 在指定的文件夹中查看文件  特别说明  时间表填写可以不按照时间顺序，使用24小时制，一个一行 时间表填写格式：起始时间 终止时间 文件夹名称 例：7:10 到 8:10 有一节语文课，应写入：7 10 8 10 语文 目前文件夹快捷选择仅支持桌面，如需使用使用，在文件源处填写：Desktop 程序文件在：build-automatic_files_backup-Desktop_Qt_5_14_2_MinGW_32_bit-Release 中的 release 文件夹 请把 release 文件夹完整下载使用，里面的文件都很重要，否则程序将无法运行 build-automatic_files_backup-Desktop_Qt_5_14_2_MinGW_32_bit-Debug 文件夹中是调试用的文件 automatic_files_backup 文件夹中是程序源代码 请不要直接运行 automatic_files_backup.exe ，除非你想看见一个大黑框  填写示例 配置文件：settings.txt #注释以‘#’开头，一个一行\n#文件源\nJ:/Application software/tools/DIY tools/文件自动保存/1.1\n#目标目录\nC:/Users/32154/Desktop/新建文件夹 (2)\n#等待时间，单位为毫秒\n10000\n#文件夹更新检测模式：1按照包含文件哈希值处理(更新及时，占用资源较大) 2按照文件夹修改时间处理(只有文件夹添加或删除文件时才会更新文件，占用资源较少)\n1\n#复制前扫描目标文件夹以保证不复制任何重复文件：1是 2否（占用资源较大，慎选！！！）\n1\n#使用预先保存的哈希文件代替扫描目标文件夹：1是 2否（每次复制或扫描文件都保存其哈希信息替代扫描目标文件夹，若需更新哈希信息，将hash.txt删除即可）\n1\n#排除的文件（夹），一行一个（不可使用通配符）\nxxx.lnk\nyyy.lnk\n数学\n课程表：1.txt 21 10 22 03 语文\n22 03 23 00 数学\n8 59 9 20 英语\n下载链接 百度网盘 提取码：lxjh\n","date":"2020-04-25T00:00:00Z","image":"https://ss0.bdstatic.com/70cFvHSh_Q1YnxGkpoWK1HF6hhy/it/u=868060462,2009612534\u0026fm=26\u0026gp=0.jpg","permalink":"https://gbwater.ga/p/%E6%96%87%E4%BB%B6%E8%87%AA%E5%8A%A8%E4%BF%9D%E5%AD%98/","title":"文件自动保存"},{"content":"点击前往深度论坛查看原帖\n起因 由于wine下载极慢，导致安装时间长达几个小时，然后又告诉我要安装gecko和mono不然没法运行.net和html程序？？？ 于是愤而下载了软件包。。。。。。（别问我是怎么下载下来的，问就是不知道 ）\n下载 百度网盘 提取码：6brv\n曲奇云\n白熊云盘\n其他 stable和devel都有，自行取用，提示依赖问题执行:\nsudo apt -f install 附：安装mono和gecko\nWINEPREFIX=\u0026lt;你的wine容器\u0026gt; \u0026lt;deepin-wine/wine\u0026gt; msiexec /i \u0026lt;mono或gecko的msi安装包\u0026gt; 完结撒花✿✿ヽ(°▽°)ノ✿","date":"2020-04-24T00:00:00Z","image":"https://timgsa.baidu.com/timg?image\u0026quality=80\u0026size=b9999_10000\u0026sec=1587721926077\u0026di=c58961c8a569ccbabfb210a88343fc94\u0026imgtype=0\u0026src=http%3A%2F%2Fn.sinaimg.cn%2Fsinacn%2F20170130%2Ff8f4-fxzyxnu9618537.jpg","permalink":"https://gbwater.ga/p/wine%E8%BD%AF%E4%BB%B6%E5%8C%85%E5%8F%8Amono%E5%92%8Cgecko/","title":"wine软件包及mono和gecko"}]